#!/usr/bin/env python3
"""
test_core_exploit_engine.py - 漏洞利用引擎单元测试

测试覆盖:
- ExploitEngine 初始化
- 利用策略选择
- 利用执行
- 结果处理
- 线程安全
- 异常处理

警告: 本测试仅用于验证代码逻辑，不实际执行任何攻击行为
"""

import pytest
import threading
import asyncio
from unittest.mock import Mock, patch, MagicMock, AsyncMock
from typing import Dict, Any, List

# 导入被测试的模块
from core.exploit.engine import (
    ExploitEngine,
    ExploitType,
    ExploitStatus,
    ExploitResult,
    ShellInfo,
    AccessInfo,
    FileInfo,
)
from core.detectors.result import DetectionResult, Severity


# ============== 测试夹具 ==============

@pytest.fixture
def mock_detection_result():
    """模拟检测结果"""
    return DetectionResult(
        vulnerable=True,
        vuln_type='sqli',
        severity=Severity.HIGH,
        url='https://example.com/api?id=1',
        param='id',
        payload="1' OR '1'='1",
        evidence='SQL error detected',
        confidence=0.9,
    )


@pytest.fixture
def mock_sqli_exploiter():
    """模拟 SQL 注入利用器"""
    with patch('core.exploit.engine.SQLiExploiter') as mock:
        exploiter_instance = Mock()
        exploiter_instance.exploit.return_value = ExploitResult(
            success=True,
            exploit_type=ExploitType.DATA_EXTRACTION,
            status=ExploitStatus.SUCCESS,
            data={'tables': ['users', 'products']},
        )
        mock.return_value = exploiter_instance
        yield mock


@pytest.fixture
def mock_rce_exploiter():
    """模拟 RCE 利用器"""
    with patch('core.exploit.engine.RCEExploiter') as mock:
        exploiter_instance = Mock()
        exploiter_instance.exploit.return_value = ExploitResult(
            success=True,
            exploit_type=ExploitType.COMMAND_EXECUTION,
            status=ExploitStatus.SUCCESS,
            shell_info=ShellInfo(
                shell_type='bash',
                os_type='linux',
                user='www-data',
                verified=True,
            ),
        )
        mock.return_value = exploiter_instance
        yield mock


# ============== ExploitEngine 初始化测试 ==============

class TestExploitEngineInit:
    """ExploitEngine 初始化测试"""

    def test_init_default(self):
        """测试默认初始化"""
        engine = ExploitEngine()

        assert engine is not None
        assert engine._exploiters is not None
        assert isinstance(engine._exploiters, dict)

    def test_init_with_config(self):
        """测试带配置初始化"""
        config = {
            'timeout': 60,
            'max_retries': 5,
            'verify_ssl': False,
        }
        engine = ExploitEngine(config=config)

        assert engine.config['timeout'] == 60
        assert engine.config['max_retries'] == 5

    def test_exploiters_dict_exists(self):
        """测试利用器字典存在"""
        engine = ExploitEngine()

        assert hasattr(engine, '_exploiters')
        assert isinstance(engine._exploiters, dict)


# ============== 利用策略选择测试 ==============

class TestExploitStrategySelection:
    """利用策略选择测试"""

    def test_get_exploiter_sqli(self, mock_detection_result):
        """测试获取 SQL 注入利用器"""
        engine = ExploitEngine()
        mock_detection_result.vuln_type = 'sqli'

        exploiter = engine._get_exploiter('sqli')

        # 可能返回 None（如果没有注册利用器），但如果返回了则必须有 exploit 方法
        if exploiter is not None:
            assert hasattr(exploiter, 'exploit'), f"Exploiter should have 'exploit' method, got {type(exploiter)}"
        else:
            assert exploiter is None, "Expected None for unregistered exploiter"

    def test_get_exploiter_unknown(self, mock_detection_result):
        """测试获取未知类型利用器"""
        engine = ExploitEngine()

        exploiter = engine._get_exploiter('unknown_vuln_type')

        assert exploiter is None


# ============== 利用执行测试 ==============

class TestExploitExecution:
    """利用执行测试"""

    def test_exploit_no_vulnerability(self, mock_detection_result):
        """测试无漏洞情况"""
        engine = ExploitEngine()
        mock_detection_result.vulnerable = False

        result = engine.exploit(mock_detection_result)

        assert result.success is False
        assert result.status == ExploitStatus.NOT_APPLICABLE

    def test_exploit_no_exploiter(self, mock_detection_result):
        """测试无可用利用器"""
        engine = ExploitEngine()
        mock_detection_result.vuln_type = 'unknown'

        result = engine.exploit(mock_detection_result)

        assert result.success is False
        assert result.status == ExploitStatus.NOT_APPLICABLE

    def test_exploit_with_targets(self, mock_detection_result):
        """测试带目标参数的利用"""
        engine = ExploitEngine()
        mock_detection_result.vuln_type = 'sqli'

        targets = {
            'queries': ['SELECT 1'],
            'extract_tables': True,
        }

        result = engine.exploit(mock_detection_result, targets=targets)

        # 应该返回结果（即使没有实际利用器）
        assert result is not None
        assert isinstance(result, ExploitResult)


# ============== 异步利用测试 ==============

class TestAsyncExploit:
    """异步利用测试"""

    @pytest.mark.asyncio
    async def test_async_exploit_basic(self, mock_detection_result):
        """测试基本异步利用"""
        engine = ExploitEngine()
        mock_detection_result.vuln_type = 'sqli'

        result = await engine.async_exploit(mock_detection_result)

        assert result is not None
        assert isinstance(result, ExploitResult)


# ============== 结果处理测试 ==============

class TestResultProcessing:
    """结果处理测试"""

    def test_exploit_result_to_dict(self):
        """测试利用结果转字典"""
        result = ExploitResult(
            success=True,
            exploit_type=ExploitType.DATA_EXTRACTION,
            status=ExploitStatus.SUCCESS,
            data={'tables': ['users']},
            shell_info=ShellInfo(shell_type='bash', os_type='linux'),
        )

        result_dict = result.to_dict()

        assert result_dict['success'] is True
        assert result_dict['exploit_type'] == 'data_extraction'
        assert result_dict['status'] == 'success'
        assert 'tables' in result_dict['data']

    def test_shell_info_to_dict(self):
        """测试 Shell 信息转字典"""
        shell_info = ShellInfo(
            shell_type='bash',
            os_type='linux',
            user='www-data',
            privileges=['read', 'write'],
            verified=True,
        )

        info_dict = shell_info.to_dict()

        assert info_dict['shell_type'] == 'bash'
        assert info_dict['os_type'] == 'linux'
        assert info_dict['user'] == 'www-data'
        assert info_dict['verified'] is True

    def test_access_info_to_dict(self):
        """测试访问信息转字典"""
        access_info = AccessInfo(
            target='http://internal.example.com',
            protocol='http',
            response_content='Internal page content',
            accessible_resources=['/admin', '/api'],
        )

        info_dict = access_info.to_dict()

        assert info_dict['target'] == 'http://internal.example.com'
        assert info_dict['protocol'] == 'http'
        assert len(info_dict['accessible_resources']) == 2

    def test_file_info_to_dict(self):
        """测试文件信息转字典"""
        file_info = FileInfo(
            path='/etc/passwd',
            content='root:x:0:0:root:/root:/bin/bash',
            size=1024,
            file_type='text',
        )

        info_dict = file_info.to_dict()

        assert info_dict['path'] == '/etc/passwd'
        assert info_dict['file_type'] == 'text'
        assert info_dict['size'] == 1024


# ============== 线程安全测试 ==============

class TestThreadSafety:
    """线程安全测试"""

    def test_concurrent_exploits(self, mock_detection_result):
        """测试并发利用"""
        engine = ExploitEngine()
        results = []
        errors = []

        def exploit_vuln():
            try:
                result = engine.exploit(mock_detection_result)
                results.append(result)
            except Exception as e:
                errors.append(e)

        threads = [threading.Thread(target=exploit_vuln) for _ in range(10)]

        for t in threads:
            t.start()

        for t in threads:
            t.join()

        # 所有利用都应该返回结果
        assert len(results) == 10
        assert len(errors) == 0


# ============== 异常处理测试 ==============

class TestExceptionHandling:
    """异常处理测试"""

    def test_invalid_detection_result(self):
        """测试无效的检测结果"""
        engine = ExploitEngine()

        # None 检测结果应该被处理
        try:
            result = engine.exploit(None)
            # 如果没有抛出异常，应该返回失败结果
            assert result.success is False
        except Exception:
            # 或者抛出异常也是可以接受的
            pass

    def test_missing_required_fields(self):
        """测试缺少必需字段"""
        engine = ExploitEngine()

        # 创建不完整的检测结果
        incomplete_result = DetectionResult(
            vulnerable=True,
            vuln_type='sqli',
            severity=Severity.HIGH,
            url='',  # 空 URL
        )

        result = engine.exploit(incomplete_result)
        # 应该能处理不完整的输入
        assert result is not None


# ============== 边界条件测试 ==============

class TestEdgeCases:
    """边界条件测试"""

    def test_empty_options(self, mock_detection_result):
        """测试空选项"""
        engine = ExploitEngine()

        mock_exploiter = Mock()
        mock_exploiter.exploit.return_value = ExploitResult(
            success=True,
            exploit_type=ExploitType.DATA_EXTRACTION,
            status=ExploitStatus.SUCCESS,
        )

        with patch.object(engine, '_select_exploiter', return_value=mock_exploiter):
            result = engine.exploit(mock_detection_result, options={})

            assert result.success is True

    def test_none_options(self, mock_detection_result):
        """测试 None 选项"""
        engine = ExploitEngine()

        mock_exploiter = Mock()
        mock_exploiter.exploit.return_value = ExploitResult(
            success=True,
            exploit_type=ExploitType.DATA_EXTRACTION,
            status=ExploitStatus.SUCCESS,
        )

        with patch.object(engine, '_select_exploiter', return_value=mock_exploiter):
            result = engine.exploit(mock_detection_result, options=None)

            assert result.success is True

    def test_very_long_payload(self, mock_detection_result):
        """测试超长 payload"""
        engine = ExploitEngine()
        mock_detection_result.payload = 'A' * 100000

        mock_exploiter = Mock()
        mock_exploiter.exploit.return_value = ExploitResult(
            success=True,
            exploit_type=ExploitType.DATA_EXTRACTION,
            status=ExploitStatus.SUCCESS,
        )

        with patch.object(engine, '_select_exploiter', return_value=mock_exploiter):
            result = engine.exploit(mock_detection_result)

            assert result is not None

    def test_unicode_in_payload(self, mock_detection_result):
        """测试 payload 中的 Unicode"""
        engine = ExploitEngine()
        mock_detection_result.payload = "' OR '1'='1' -- 你好"

        mock_exploiter = Mock()
        mock_exploiter.exploit.return_value = ExploitResult(
            success=True,
            exploit_type=ExploitType.DATA_EXTRACTION,
            status=ExploitStatus.SUCCESS,
        )

        with patch.object(engine, '_select_exploiter', return_value=mock_exploiter):
            result = engine.exploit(mock_detection_result)

            assert result is not None


# ============== 集成测试 ==============

class TestIntegration:
    """集成测试"""

    def test_full_exploit_workflow(self):
        """测试完整利用工作流"""
        engine = ExploitEngine()

        # 1. 创建检测结果
        detection = DetectionResult(
            vulnerable=True,
            vuln_type='sqli',
            severity=Severity.HIGH,
            url='https://example.com/api?id=1',
            param='id',
            payload="1' OR '1'='1",
        )

        # 2. 执行利用
        result = engine.exploit(detection)

        # 3. 验证结果
        assert result is not None
        assert isinstance(result, ExploitResult)
        assert result.vuln_type == 'sqli'

    def test_multiple_vulnerabilities_exploit(self):
        """测试多个漏洞利用"""
        engine = ExploitEngine()

        # 创建多个不同类型的检测结果
        detections = [
            DetectionResult(
                vulnerable=True,
                vuln_type='sqli',
                severity=Severity.HIGH,
                url='https://example.com/api?id=1',
            ),
            DetectionResult(
                vulnerable=True,
                vuln_type='xss',
                severity=Severity.MEDIUM,
                url='https://example.com/search?q=test',
            ),
            DetectionResult(
                vulnerable=True,
                vuln_type='rce',
                severity=Severity.CRITICAL,
                url='https://example.com/exec',
            ),
        ]

        results = []
        for detection in detections:
            result = engine.exploit(detection)
            results.append(result)

        # 验证所有利用结果
        assert len(results) == 3
        assert all(isinstance(r, ExploitResult) for r in results)


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
