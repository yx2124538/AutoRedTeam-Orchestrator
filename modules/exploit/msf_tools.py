#!/usr/bin/env python3
"""
Metasploit框架工具集
"""

import subprocess
import json
import logging
import tempfile
import os
from typing import Any, Dict, List
from dataclasses import dataclass, field

from core.tool_registry import BaseTool, ToolCategory, ToolParameter

logger = logging.getLogger(__name__)


@dataclass
class MetasploitTool(BaseTool):
    """Metasploit利用"""
    name: str = "metasploit"
    description: str = "Metasploit - 漏洞利用框架"
    category: ToolCategory = ToolCategory.EXPLOIT
    parameters: List[ToolParameter] = field(default_factory=lambda: [
        ToolParameter("module", "string", "模块路径(如: exploit/windows/smb/ms17_010_eternalblue)", required=True),
        ToolParameter("rhosts", "string", "目标地址", required=True),
        ToolParameter("rport", "integer", "目标端口", required=False, default=0),
        ToolParameter("lhost", "string", "本地监听地址", required=False, default=""),
        ToolParameter("lport", "integer", "本地监听端口", required=False, default=4444),
        ToolParameter("payload", "string", "Payload路径", required=False, default=""),
        ToolParameter("options", "string", "额外选项(JSON格式)", required=False, default="{}"),
        ToolParameter("check_only", "boolean", "仅检测不利用", required=False, default=False),
    ])
    requires_root: bool = True
    timeout: int = 600
    
    def execute(self, params: Dict[str, Any], session_id: str = None) -> Dict[str, Any]:
        module = params["module"]
        rhosts = params["rhosts"]
        rport = params.get("rport", 0)
        lhost = params.get("lhost", "")
        lport = params.get("lport", 4444)
        payload = params.get("payload", "")
        options = params.get("options", "{}")
        check_only = params.get("check_only", False)
        
        # 构建MSF资源脚本
        rc_content = f"""
use {module}
set RHOSTS {rhosts}
"""
        
        if rport > 0:
            rc_content += f"set RPORT {rport}\n"
        if lhost:
            rc_content += f"set LHOST {lhost}\n"
        if lport:
            rc_content += f"set LPORT {lport}\n"
        if payload:
            rc_content += f"set PAYLOAD {payload}\n"
        
        # 解析额外选项
        try:
            extra_opts = json.loads(options)
            for key, value in extra_opts.items():
                rc_content += f"set {key} {value}\n"
        except json.JSONDecodeError:
            pass
        
        if check_only:
            rc_content += "check\n"
        else:
            rc_content += "run\n"
        
        rc_content += "exit\n"
        
        # 写入临时文件
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
            f.write(rc_content)
            rc_file = f.name
        
        try:
            cmd = ["msfconsole", "-q", "-r", rc_file]
            logger.info(f"执行Metasploit: {module} -> {rhosts}")
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            # 解析结果
            output = result.stdout
            parsed = self._parse_output(output)
            
            return {
                "success": True,
                "module": module,
                "target": rhosts,
                **parsed,
                "raw_output": output,
                "rc_script": rc_content
            }
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Metasploit执行超时"}
        except FileNotFoundError:
            return {"success": False, "error": "msfconsole未安装，请安装Metasploit Framework"}
        except Exception as e:
            return {"success": False, "error": str(e)}
        finally:
            if os.path.exists(rc_file):
                os.unlink(rc_file)
    
    def _parse_output(self, output: str) -> Dict[str, Any]:
        """解析MSF输出"""
        result = {
            "exploit_success": False,
            "session_opened": False,
            "vulnerable": False,
            "sessions": [],
            "messages": []
        }
        
        for line in output.split('\n'):
            line_lower = line.lower()
            
            if "session" in line_lower and "opened" in line_lower:
                result["session_opened"] = True
                result["exploit_success"] = True
            
            if "the target is vulnerable" in line_lower:
                result["vulnerable"] = True
            
            if "exploit completed" in line_lower and "no session" not in line_lower:
                result["exploit_success"] = True
            
            if "[+]" in line or "[-]" in line or "[*]" in line:
                result["messages"].append(line.strip())
        
        return result


@dataclass
class MsfVenomTool(BaseTool):
    """MSFVenom Payload生成"""
    name: str = "msfvenom"
    description: str = "MSFVenom - 生成Payload和Shellcode"
    category: ToolCategory = ToolCategory.EXPLOIT
    parameters: List[ToolParameter] = field(default_factory=lambda: [
        ToolParameter("payload", "string", "Payload类型", required=True),
        ToolParameter("lhost", "string", "本地监听地址", required=True),
        ToolParameter("lport", "integer", "本地监听端口", required=True),
        ToolParameter("format", "string", "输出格式", required=False, default="exe",
                     choices=["exe", "elf", "dll", "raw", "python", "bash", "powershell", 
                             "c", "csharp", "java", "php", "asp", "aspx", "war"]),
        ToolParameter("encoder", "string", "编码器", required=False, default="",
                     choices=["", "x86/shikata_ga_nai", "x64/xor", "php/base64"]),
        ToolParameter("iterations", "integer", "编码迭代次数", required=False, default=1),
        ToolParameter("output_file", "string", "输出文件路径", required=False, default=""),
        ToolParameter("arch", "string", "架构", required=False, default="",
                     choices=["", "x86", "x64", "armle", "aarch64"]),
        ToolParameter("platform", "string", "平台", required=False, default="",
                     choices=["", "windows", "linux", "osx", "android", "php", "java"]),
    ])
    timeout: int = 120
    
    def execute(self, params: Dict[str, Any], session_id: str = None) -> Dict[str, Any]:
        payload = params["payload"]
        lhost = params["lhost"]
        lport = params["lport"]
        output_format = params.get("format", "exe")
        encoder = params.get("encoder", "")
        iterations = params.get("iterations", 1)
        output_file = params.get("output_file", "")
        arch = params.get("arch", "")
        platform = params.get("platform", "")
        
        cmd = [
            "msfvenom",
            "-p", payload,
            f"LHOST={lhost}",
            f"LPORT={lport}",
            "-f", output_format
        ]
        
        if encoder:
            cmd.extend(["-e", encoder])
            cmd.extend(["-i", str(iterations)])
        
        if arch:
            cmd.extend(["-a", arch])
        
        if platform:
            cmd.extend(["--platform", platform])
        
        if output_file:
            cmd.extend(["-o", output_file])
        
        try:
            logger.info(f"执行MSFVenom: {payload}")
            result = subprocess.run(
                cmd,
                capture_output=True,
                timeout=self.timeout
            )
            
            output_info = {}
            if output_file:
                output_info["file_path"] = output_file
                output_info["file_exists"] = os.path.exists(output_file)
                if os.path.exists(output_file):
                    output_info["file_size"] = os.path.getsize(output_file)
            else:
                # 输出到stdout，可能是shellcode
                output_info["shellcode_size"] = len(result.stdout)
                if output_format in ["python", "c", "csharp", "bash", "powershell"]:
                    output_info["shellcode"] = result.stdout.decode('utf-8', errors='ignore')
            
            return {
                "success": result.returncode == 0,
                "payload": payload,
                "format": output_format,
                "lhost": lhost,
                "lport": lport,
                **output_info,
                "command": ' '.join(cmd)
            }
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Payload生成超时"}
        except FileNotFoundError:
            return {"success": False, "error": "msfvenom未安装"}
        except Exception as e:
            return {"success": False, "error": str(e)}


@dataclass
class MsfSearchTool(BaseTool):
    """MSF模块搜索"""
    name: str = "msf_search"
    description: str = "MSF搜索 - 搜索Metasploit模块"
    category: ToolCategory = ToolCategory.EXPLOIT
    parameters: List[ToolParameter] = field(default_factory=lambda: [
        ToolParameter("query", "string", "搜索关键词", required=True),
        ToolParameter("type", "string", "模块类型", required=False, default="",
                     choices=["", "exploit", "auxiliary", "post", "payload", "encoder"]),
    ])
    timeout: int = 60
    
    def execute(self, params: Dict[str, Any], session_id: str = None) -> Dict[str, Any]:
        query = params["query"]
        module_type = params.get("type", "")
        
        search_cmd = f"search {query}"
        if module_type:
            search_cmd += f" type:{module_type}"
        
        # 使用msfconsole搜索
        cmd = ["msfconsole", "-q", "-x", f"{search_cmd}; exit"]
        
        try:
            logger.info(f"搜索MSF模块: {query}")
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            modules = self._parse_search(result.stdout)
            
            return {
                "success": True,
                "query": query,
                "modules": modules,
                "total_found": len(modules)
            }
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "搜索超时"}
        except FileNotFoundError:
            return {"success": False, "error": "msfconsole未安装"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _parse_search(self, output: str) -> List[Dict[str, str]]:
        """解析搜索结果"""
        modules = []
        
        for line in output.split('\n'):
            # 格式: #  Name                              Disclosure Date  Rank       Description
            if 'exploit/' in line or 'auxiliary/' in line or 'post/' in line:
                parts = line.split()
                if len(parts) >= 3:
                    modules.append({
                        "name": parts[1] if parts[0].isdigit() else parts[0],
                        "rank": parts[-2] if len(parts) > 3 else "",
                        "description": " ".join(parts[3:]) if len(parts) > 3 else ""
                    })
        
        return modules[:50]  # 限制数量
