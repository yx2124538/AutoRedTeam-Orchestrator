#!/usr/bin/env python3
"""
权限提升工具集
"""

import subprocess
import logging
from typing import Any, Dict, List
from dataclasses import dataclass, field

from core.tool_registry import BaseTool, ToolCategory, ToolParameter

logger = logging.getLogger(__name__)


@dataclass
class LinPEASTool(BaseTool):
    """LinPEAS权限提升检测"""
    name: str = "linpeas"
    description: str = "LinPEAS - Linux权限提升辅助脚本"
    category: ToolCategory = ToolCategory.POST_EXPLOIT
    parameters: List[ToolParameter] = field(default_factory=lambda: [
        ToolParameter("mode", "string", "运行模式", required=False, default="all",
                     choices=["all", "system", "container", "cloud", "procs", 
                             "network", "users", "software", "interesting"]),
        ToolParameter("output_file", "string", "输出文件路径", required=False, default=""),
    ])
    timeout: int = 600
    
    def execute(self, params: Dict[str, Any], session_id: str = None) -> Dict[str, Any]:
        mode = params.get("mode", "all")
        output_file = params.get("output_file", "")
        
        # LinPEAS脚本路径
        linpeas_paths = [
            "/usr/share/peass/linpeas/linpeas.sh",
            "/opt/linpeas/linpeas.sh",
            "./linpeas.sh"
        ]
        
        linpeas_path = None
        import os
        for path in linpeas_paths:
            if os.path.exists(path):
                linpeas_path = path
                break
        
        if not linpeas_path:
            return {
                "success": False,
                "error": "LinPEAS未找到。请下载: curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh -o linpeas.sh",
                "download_commands": {
                    "curl": "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh -o linpeas.sh && chmod +x linpeas.sh",
                    "wget": "wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh && chmod +x linpeas.sh"
                }
            }
        
        cmd = ["bash", linpeas_path]
        
        # 添加模式参数
        mode_flags = {
            "system": "-s",
            "container": "-D",
            "cloud": "-c",
            "procs": "-P",
            "network": "-N",
            "users": "-u",
            "software": "-S",
            "interesting": "-i"
        }
        
        if mode != "all" and mode in mode_flags:
            cmd.append(mode_flags[mode])
        
        try:
            logger.info(f"执行LinPEAS: {' '.join(cmd)}")
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            output = result.stdout
            
            # 保存到文件
            if output_file:
                with open(output_file, 'w') as f:
                    f.write(output)
            
            # 解析关键发现
            findings = self._parse_findings(output)
            
            return {
                "success": True,
                "mode": mode,
                "findings": findings,
                "output_file": output_file if output_file else None,
                "raw_output_length": len(output),
                "command": ' '.join(cmd)
            }
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "LinPEAS执行超时"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _parse_findings(self, output: str) -> Dict[str, List[str]]:
        """解析LinPEAS关键发现"""
        findings = {
            "critical": [],
            "high": [],
            "medium": [],
            "interesting_files": [],
            "possible_privesc": []
        }
        
        lines = output.split('\n')
        current_section = None
        
        for line in lines:
            # 检测高亮和重要发现
            if "99%" in line or "95%" in line or "Highly probable" in line:
                findings["critical"].append(line.strip())
            elif "80%" in line or "70%" in line or "Probable" in line:
                findings["high"].append(line.strip())
            elif "CVE" in line:
                findings["possible_privesc"].append(line.strip())
            elif "/etc/shadow" in line and "readable" in line.lower():
                findings["critical"].append(f"Shadow文件可读: {line.strip()}")
            elif "SUID" in line or "SGID" in line:
                findings["medium"].append(line.strip())
            elif ".ssh" in line or "id_rsa" in line:
                findings["interesting_files"].append(line.strip())
        
        # 限制每个类别数量
        for key in findings:
            findings[key] = findings[key][:20]
        
        return findings


@dataclass
class WinPEASTool(BaseTool):
    """WinPEAS权限提升检测"""
    name: str = "winpeas"
    description: str = "WinPEAS - Windows权限提升辅助脚本"
    category: ToolCategory = ToolCategory.POST_EXPLOIT
    parameters: List[ToolParameter] = field(default_factory=lambda: [
        ToolParameter("mode", "string", "运行模式", required=False, default="all",
                     choices=["all", "systeminfo", "userinfo", "processinfo", 
                             "servicesinfo", "applicationsinfo", "networkinfo",
                             "windowscreds", "browserinfo", "filesinfo"]),
    ])
    timeout: int = 600
    
    def execute(self, params: Dict[str, Any], session_id: str = None) -> Dict[str, Any]:
        mode = params.get("mode", "all")
        
        # WinPEAS需要在Windows上运行，这里返回使用说明
        return {
            "success": True,
            "note": "WinPEAS需要在目标Windows系统上执行",
            "download_commands": {
                "exe": "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASany.exe -o winpeas.exe",
                "bat": "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEAS.bat -o winpeas.bat"
            },
            "usage": {
                "all": ".\\winpeas.exe",
                "quiet": ".\\winpeas.exe quiet",
                "specific": f".\\winpeas.exe {mode}"
            },
            "modes_available": [
                "systeminfo - 系统信息",
                "userinfo - 用户信息",
                "processinfo - 进程信息",
                "servicesinfo - 服务信息",
                "applicationsinfo - 应用信息",
                "networkinfo - 网络信息",
                "windowscreds - Windows凭证",
                "browserinfo - 浏览器信息",
                "filesinfo - 文件信息"
            ]
        }


@dataclass
class LinuxExploitSuggesterTool(BaseTool):
    """Linux Exploit Suggester"""
    name: str = "linux_exploit_suggester"
    description: str = "Linux Exploit Suggester - 建议可能的内核漏洞利用"
    category: ToolCategory = ToolCategory.POST_EXPLOIT
    parameters: List[ToolParameter] = field(default_factory=lambda: [
        ToolParameter("kernel_version", "string", "内核版本(可选)", required=False, default=""),
    ])
    timeout: int = 120
    
    def execute(self, params: Dict[str, Any], session_id: str = None) -> Dict[str, Any]:
        kernel_version = params.get("kernel_version", "")
        
        # 查找脚本
        import os
        script_paths = [
            "/usr/share/linux-exploit-suggester/linux-exploit-suggester.sh",
            "/opt/linux-exploit-suggester/linux-exploit-suggester.sh",
            "./linux-exploit-suggester.sh"
        ]
        
        script_path = None
        for path in script_paths:
            if os.path.exists(path):
                script_path = path
                break
        
        if not script_path:
            return {
                "success": False,
                "error": "Linux Exploit Suggester未找到",
                "download_command": "git clone https://github.com/mzet-/linux-exploit-suggester.git"
            }
        
        cmd = ["bash", script_path]
        if kernel_version:
            cmd.extend(["-k", kernel_version])
        
        try:
            logger.info(f"执行Linux Exploit Suggester: {' '.join(cmd)}")
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            exploits = self._parse_exploits(result.stdout)
            
            return {
                "success": True,
                "kernel_version": kernel_version if kernel_version else "current",
                "exploits": exploits,
                "total_found": len(exploits),
                "raw_output": result.stdout
            }
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "执行超时"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _parse_exploits(self, output: str) -> List[Dict[str, str]]:
        """解析漏洞利用建议"""
        exploits = []
        
        import re
        # 匹配CVE和漏洞名称
        pattern = r"\[CVE-(\d{4}-\d+)\]\s*(.+?)(?:\n|$)"
        
        for match in re.finditer(pattern, output):
            exploits.append({
                "cve": f"CVE-{match.group(1)}",
                "name": match.group(2).strip()
            })
        
        return exploits
