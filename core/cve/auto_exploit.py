#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE 自动利用引擎 - AI PoC Generator + Exploit Engine 集成

实现完整的自动化利用链路:
CVE ID → 搜索CVE详情 → AI生成PoC → 验证PoC → 执行利用 → 返回结果

作者: AutoRedTeam-Orchestrator
警告: 本工具仅用于授权安全测试，禁止用于未授权的渗透测试活动
"""

import logging
import asyncio
import tempfile
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Union
from pathlib import Path
from enum import Enum
from datetime import datetime

logger = logging.getLogger(__name__)


class AutoExploitStatus(Enum):
    """自动利用状态"""
    SUCCESS = 'success'
    PARTIAL = 'partial'
    POC_GENERATED = 'poc_generated'
    CVE_NOT_FOUND = 'cve_not_found'
    POC_GENERATION_FAILED = 'poc_generation_failed'
    EXPLOIT_FAILED = 'exploit_failed'
    TARGET_NOT_VULNERABLE = 'target_not_vulnerable'
    ERROR = 'error'


@dataclass
class AutoExploitResult:
    """自动利用结果"""
    status: AutoExploitStatus
    cve_id: str
    target: str

    # CVE 信息
    cve_info: Optional[Dict[str, Any]] = None

    # PoC 相关
    poc_yaml: Optional[str] = None
    poc_template_path: Optional[str] = None
    vuln_type: str = ''

    # 利用结果
    vulnerable: bool = False
    exploit_data: Optional[Dict[str, Any]] = None
    evidence: str = ''

    # 元数据
    execution_time_ms: float = 0.0
    error: Optional[str] = None
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

    # 详细步骤记录
    steps: List[Dict[str, Any]] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            'status': self.status.value,
            'cve_id': self.cve_id,
            'target': self.target,
            'cve_info': self.cve_info,
            'poc_yaml': self.poc_yaml,
            'poc_template_path': self.poc_template_path,
            'vuln_type': self.vuln_type,
            'vulnerable': self.vulnerable,
            'exploit_data': self.exploit_data,
            'evidence': self.evidence,
            'execution_time_ms': self.execution_time_ms,
            'error': self.error,
            'timestamp': self.timestamp,
            'steps': self.steps,
        }

    @property
    def success(self) -> bool:
        """是否成功"""
        return self.status in (AutoExploitStatus.SUCCESS, AutoExploitStatus.PARTIAL)

    def add_step(self, step_name: str, success: bool, details: Any = None):
        """添加执行步骤"""
        self.steps.append({
            'step': step_name,
            'success': success,
            'details': details,
            'timestamp': datetime.now().isoformat(),
        })


class CVEAutoExploitEngine:
    """
    CVE 自动利用引擎

    集成 AI PoC Generator + PoC Engine + Exploit Engine，实现:
    1. CVE 搜索与信息提取
    2. AI 智能生成 PoC 模板
    3. PoC 验证执行
    4. 漏洞深度利用

    Usage:
        engine = CVEAutoExploitEngine()

        # 方式1: 通过 CVE ID 自动利用
        result = await engine.auto_exploit_by_cve(
            target="https://vulnerable-site.com",
            cve_id="CVE-2024-1234"
        )

        # 方式2: 通过 CVE 描述生成 PoC 并利用
        result = await engine.exploit_with_description(
            target="https://vulnerable-site.com",
            cve_id="CVE-2024-1234",
            description="SQL injection in the search parameter...",
            severity="high"
        )

        if result.success:
            print(f"漏洞验证成功: {result.evidence}")
            print(f"提取数据: {result.exploit_data}")

    警告: 本工具仅用于授权安全测试
    """

    def __init__(
        self,
        config: Optional[Dict[str, Any]] = None,
        poc_template_dir: Optional[Path] = None,
    ):
        """
        初始化引擎

        Args:
            config: 配置字典
            poc_template_dir: PoC 模板存储目录
        """
        self.config = config or {}
        self.poc_template_dir = poc_template_dir or Path(tempfile.gettempdir()) / 'autoredt_poc'
        self.poc_template_dir.mkdir(parents=True, exist_ok=True)

        # 延迟加载组件
        self._cve_manager = None
        self._poc_generator = None
        self._poc_engine = None
        self._exploit_engine = None

        # 配置
        self.timeout = self.config.get('timeout', 60)
        self.verify_before_exploit = self.config.get('verify_before_exploit', True)
        self.save_poc_templates = self.config.get('save_poc_templates', True)

        logger.info("[CVEAutoExploitEngine] 初始化完成")

    @property
    def cve_manager(self):
        """获取 CVE 管理器"""
        if self._cve_manager is None:
            try:
                from core.cve.manager import get_cve_manager
                self._cve_manager = get_cve_manager()
            except ImportError:
                logger.warning("CVEManager 不可用")
        return self._cve_manager

    @property
    def poc_generator(self):
        """获取 AI PoC 生成器"""
        if self._poc_generator is None:
            try:
                from core.cve.ai_poc_generator import AIPoCGenerator
                self._poc_generator = AIPoCGenerator()
            except ImportError:
                logger.warning("AIPoCGenerator 不可用")
        return self._poc_generator

    @property
    def poc_engine(self):
        """获取 PoC 执行引擎"""
        if self._poc_engine is None:
            try:
                from core.cve.poc_engine import get_poc_engine
                self._poc_engine = get_poc_engine()
            except ImportError:
                logger.warning("PoCEngine 不可用")
        return self._poc_engine

    @property
    def exploit_engine(self):
        """获取漏洞利用引擎"""
        if self._exploit_engine is None:
            try:
                from core.exploit.engine import ExploitEngine
                self._exploit_engine = ExploitEngine(self.config)
            except ImportError:
                logger.warning("ExploitEngine 不可用")
        return self._exploit_engine

    async def auto_exploit_by_cve(
        self,
        target: str,
        cve_id: str,
        custom_vars: Optional[Dict[str, str]] = None,
    ) -> AutoExploitResult:
        """
        通过 CVE ID 自动利用漏洞

        完整流程:
        1. 搜索 CVE 详情
        2. AI 生成 PoC 模板
        3. 执行 PoC 验证
        4. 深度利用 (如果验证成功)

        Args:
            target: 目标 URL
            cve_id: CVE 编号 (如 CVE-2024-1234)
            custom_vars: 自定义变量 (传递给 PoC 模板)

        Returns:
            AutoExploitResult: 利用结果
        """
        start_time = time.time()
        result = AutoExploitResult(
            status=AutoExploitStatus.ERROR,
            cve_id=cve_id,
            target=target,
        )

        try:
            # Step 1: 搜索 CVE 信息
            cve_info = await self._search_cve(cve_id)
            if not cve_info:
                result.status = AutoExploitStatus.CVE_NOT_FOUND
                result.error = f"未找到 CVE: {cve_id}"
                result.add_step('search_cve', False, {'error': result.error})
                return result

            result.cve_info = cve_info
            result.add_step('search_cve', True, {
                'description': cve_info.get('description', '')[:200],
                'severity': cve_info.get('severity', 'unknown'),
            })

            # Step 2: 生成 PoC
            description = cve_info.get('description', '')
            severity = cve_info.get('severity', 'medium')

            poc_yaml = self._generate_poc(cve_id, description, severity)
            if not poc_yaml:
                result.status = AutoExploitStatus.POC_GENERATION_FAILED
                result.error = "PoC 生成失败"
                result.add_step('generate_poc', False, {'error': result.error})
                return result

            result.poc_yaml = poc_yaml
            result.add_step('generate_poc', True, {'poc_length': len(poc_yaml)})

            # Step 3: 保存 PoC 模板
            if self.save_poc_templates:
                template_path = self._save_poc_template(cve_id, poc_yaml)
                result.poc_template_path = str(template_path)
                result.add_step('save_poc', True, {'path': str(template_path)})

            # Step 4: 执行 PoC 验证
            poc_result = await self._execute_poc(target, poc_yaml, custom_vars)

            if poc_result and poc_result.get('vulnerable'):
                result.vulnerable = True
                result.evidence = poc_result.get('evidence', '')
                result.vuln_type = self._extract_vuln_type(description)
                result.add_step('verify_poc', True, {
                    'vulnerable': True,
                    'evidence': result.evidence[:500],
                })

                # Step 5: 深度利用
                exploit_result = await self._deep_exploit(
                    target, result.vuln_type, poc_result, custom_vars
                )

                if exploit_result:
                    result.exploit_data = exploit_result
                    result.status = AutoExploitStatus.SUCCESS
                    result.add_step('deep_exploit', True, {
                        'data_extracted': bool(exploit_result),
                    })
                else:
                    result.status = AutoExploitStatus.PARTIAL
                    result.add_step('deep_exploit', False, {
                        'reason': '深度利用未返回数据',
                    })
            else:
                result.status = AutoExploitStatus.TARGET_NOT_VULNERABLE
                result.add_step('verify_poc', False, {
                    'vulnerable': False,
                    'error': poc_result.get('error') if poc_result else 'PoC 执行失败',
                })

        except Exception as e:
            logger.exception(f"[CVEAutoExploitEngine] 自动利用失败: {e}")
            result.status = AutoExploitStatus.ERROR
            result.error = str(e)
            result.add_step('error', False, {'exception': str(e)})

        finally:
            result.execution_time_ms = (time.time() - start_time) * 1000

        return result

    async def exploit_with_description(
        self,
        target: str,
        cve_id: str,
        description: str,
        severity: str = 'medium',
        custom_vars: Optional[Dict[str, str]] = None,
    ) -> AutoExploitResult:
        """
        通过 CVE 描述直接生成 PoC 并利用

        当已知 CVE 描述时，跳过搜索步骤直接生成 PoC

        Args:
            target: 目标 URL
            cve_id: CVE 编号
            description: CVE 描述
            severity: 严重性级别
            custom_vars: 自定义变量

        Returns:
            AutoExploitResult: 利用结果
        """
        start_time = time.time()
        result = AutoExploitResult(
            status=AutoExploitStatus.ERROR,
            cve_id=cve_id,
            target=target,
            cve_info={'description': description, 'severity': severity},
        )

        try:
            # Step 1: 生成 PoC
            poc_yaml = self._generate_poc(cve_id, description, severity)
            if not poc_yaml:
                result.status = AutoExploitStatus.POC_GENERATION_FAILED
                result.error = "PoC 生成失败"
                result.add_step('generate_poc', False, {'error': result.error})
                return result

            result.poc_yaml = poc_yaml
            result.vuln_type = self._extract_vuln_type(description)
            result.add_step('generate_poc', True, {
                'poc_length': len(poc_yaml),
                'vuln_type': result.vuln_type,
            })

            # Step 2: 保存 PoC 模板
            if self.save_poc_templates:
                template_path = self._save_poc_template(cve_id, poc_yaml)
                result.poc_template_path = str(template_path)

            # Step 3: 执行 PoC 验证
            poc_result = await self._execute_poc(target, poc_yaml, custom_vars)

            if poc_result and poc_result.get('vulnerable'):
                result.vulnerable = True
                result.evidence = poc_result.get('evidence', '')
                result.add_step('verify_poc', True, {'vulnerable': True})

                # Step 4: 深度利用
                exploit_result = await self._deep_exploit(
                    target, result.vuln_type, poc_result, custom_vars
                )

                if exploit_result:
                    result.exploit_data = exploit_result
                    result.status = AutoExploitStatus.SUCCESS
                    result.add_step('deep_exploit', True, {})
                else:
                    result.status = AutoExploitStatus.PARTIAL
            else:
                result.status = AutoExploitStatus.TARGET_NOT_VULNERABLE
                result.add_step('verify_poc', False, {'vulnerable': False})

        except Exception as e:
            logger.exception(f"[CVEAutoExploitEngine] 利用失败: {e}")
            result.status = AutoExploitStatus.ERROR
            result.error = str(e)

        finally:
            result.execution_time_ms = (time.time() - start_time) * 1000

        return result

    def generate_poc_only(
        self,
        cve_id: str,
        description: str,
        severity: str = 'medium',
    ) -> Optional[str]:
        """
        仅生成 PoC (不执行利用)

        适用于需要手动审核 PoC 的场景

        Args:
            cve_id: CVE 编号
            description: CVE 描述
            severity: 严重性级别

        Returns:
            YAML 格式的 PoC 模板，失败返回 None
        """
        return self._generate_poc(cve_id, description, severity)

    async def _search_cve(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """搜索 CVE 信息"""
        if not self.cve_manager:
            logger.warning("CVEManager 不可用，尝试使用备用搜索")
            return await self._fallback_cve_search(cve_id)

        try:
            # 使用 CVEManager 搜索
            results = self.cve_manager.search(cve_id, limit=1)
            if results:
                cve = results[0]
                return {
                    'cve_id': getattr(cve, 'cve_id', cve_id),
                    'description': getattr(cve, 'description', ''),
                    'severity': getattr(cve, 'severity', 'medium'),
                    'cvss_score': getattr(cve, 'cvss_score', 0.0),
                    'references': getattr(cve, 'references', []),
                    'cwe_id': getattr(cve, 'cwe_id', ''),
                }
        except Exception as e:
            logger.warning(f"CVE 搜索失败: {e}")

        return await self._fallback_cve_search(cve_id)

    async def _fallback_cve_search(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """备用 CVE 搜索 (使用在线 API)"""
        try:
            import aiohttp

            # 使用 NVD API
            url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"

            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=30) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        vulns = data.get('vulnerabilities', [])
                        if vulns:
                            cve_data = vulns[0].get('cve', {})
                            desc_list = cve_data.get('descriptions', [])
                            description = ''
                            for d in desc_list:
                                if d.get('lang') == 'en':
                                    description = d.get('value', '')
                                    break

                            # 提取 CVSS 分数
                            metrics = cve_data.get('metrics', {})
                            cvss_score = 0.0
                            severity = 'medium'

                            for cvss_version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
                                if cvss_version in metrics:
                                    cvss_data = metrics[cvss_version][0].get('cvssData', {})
                                    cvss_score = cvss_data.get('baseScore', 0.0)
                                    severity = cvss_data.get('baseSeverity', 'MEDIUM').lower()
                                    break

                            return {
                                'cve_id': cve_id,
                                'description': description,
                                'severity': severity,
                                'cvss_score': cvss_score,
                                'references': [],
                            }
        except Exception as e:
            logger.warning(f"备用 CVE 搜索失败: {e}")

        return None

    def _generate_poc(
        self,
        cve_id: str,
        description: str,
        severity: str,
    ) -> Optional[str]:
        """生成 PoC 模板"""
        if not self.poc_generator:
            logger.error("AI PoC Generator 不可用")
            return None

        try:
            poc_yaml = self.poc_generator.generate_poc(
                cve_id=cve_id,
                cve_description=description,
                severity=severity,
            )
            return poc_yaml
        except Exception as e:
            logger.exception(f"PoC 生成失败: {e}")
            return None

    def _save_poc_template(self, cve_id: str, poc_yaml: str) -> Path:
        """保存 PoC 模板到文件"""
        safe_name = cve_id.replace(':', '-').replace('/', '-')
        template_path = self.poc_template_dir / f"{safe_name}.yaml"

        template_path.write_text(poc_yaml, encoding='utf-8')
        logger.info(f"PoC 模板已保存: {template_path}")

        return template_path

    async def _execute_poc(
        self,
        target: str,
        poc_yaml: str,
        custom_vars: Optional[Dict[str, str]] = None,
    ) -> Optional[Dict[str, Any]]:
        """执行 PoC 验证"""
        if not self.poc_engine:
            logger.warning("PoCEngine 不可用，跳过验证")
            return None

        try:
            # 解析 YAML 并执行
            result = await asyncio.to_thread(
                self.poc_engine.execute_from_yaml,
                target,
                poc_yaml,
                custom_vars or {},
            )

            if hasattr(result, 'to_dict'):
                return result.to_dict()
            return result

        except AttributeError:
            # poc_engine 可能没有 execute_from_yaml 方法
            # 尝试保存文件后执行
            try:
                import tempfile
                with tempfile.NamedTemporaryFile(
                    mode='w', suffix='.yaml', delete=False, encoding='utf-8'
                ) as f:
                    f.write(poc_yaml)
                    temp_path = f.name

                result = await asyncio.to_thread(
                    self.poc_engine.execute,
                    target,
                    Path(temp_path),
                    custom_vars or {},
                )

                Path(temp_path).unlink(missing_ok=True)

                if hasattr(result, 'to_dict'):
                    return result.to_dict()
                return result

            except Exception as e:
                logger.warning(f"PoC 执行失败: {e}")
                return None

        except Exception as e:
            logger.warning(f"PoC 执行失败: {e}")
            return None

    async def _deep_exploit(
        self,
        target: str,
        vuln_type: str,
        poc_result: Dict[str, Any],
        custom_vars: Optional[Dict[str, str]] = None,
    ) -> Optional[Dict[str, Any]]:
        """深度利用"""
        if not self.exploit_engine:
            logger.warning("ExploitEngine 不可用，跳过深度利用")
            return None

        try:
            # 构造检测结果对象
            from dataclasses import dataclass

            @dataclass
            class DetectionResult:
                vulnerable: bool
                vuln_type: str
                url: str
                param: str = ''
                payload: str = ''
                evidence: str = ''

            detection = DetectionResult(
                vulnerable=True,
                vuln_type=vuln_type,
                url=target,
                param=poc_result.get('param', ''),
                payload=poc_result.get('payload', ''),
                evidence=poc_result.get('evidence', ''),
            )

            # 调用利用引擎
            exploit_result = await self.exploit_engine.async_exploit(
                detection,
                targets=custom_vars,
            )

            if exploit_result.success:
                return exploit_result.to_dict()

        except Exception as e:
            logger.warning(f"深度利用失败: {e}")

        return None

    def _extract_vuln_type(self, description: str) -> str:
        """从描述中提取漏洞类型"""
        if not self.poc_generator:
            return 'unknown'

        try:
            from core.cve.ai_poc_generator import KeywordMatcher
            vuln_type = KeywordMatcher.identify_vuln_type(description)
            return vuln_type.value
        except Exception:
            # 简单的关键词匹配
            desc_lower = description.lower()
            type_map = {
                'sql injection': 'sqli',
                'sqli': 'sqli',
                'cross-site scripting': 'xss',
                'xss': 'xss',
                'remote code execution': 'rce',
                'rce': 'rce',
                'command injection': 'rce',
                'path traversal': 'path_traversal',
                'directory traversal': 'path_traversal',
                'ssrf': 'ssrf',
                'xxe': 'xxe',
                'authentication bypass': 'auth_bypass',
            }

            for keyword, vuln_type in type_map.items():
                if keyword in desc_lower:
                    return vuln_type

            return 'unknown'


# 全局实例
_auto_exploit_engine: Optional[CVEAutoExploitEngine] = None


def get_auto_exploit_engine(
    config: Optional[Dict[str, Any]] = None,
) -> CVEAutoExploitEngine:
    """获取全局自动利用引擎实例"""
    global _auto_exploit_engine
    if _auto_exploit_engine is None:
        _auto_exploit_engine = CVEAutoExploitEngine(config)
    return _auto_exploit_engine


# 便捷函数
async def auto_exploit_cve(
    target: str,
    cve_id: str,
    custom_vars: Optional[Dict[str, str]] = None,
) -> AutoExploitResult:
    """
    便捷函数: 通过 CVE ID 自动利用

    Args:
        target: 目标 URL
        cve_id: CVE 编号
        custom_vars: 自定义变量

    Returns:
        AutoExploitResult: 利用结果
    """
    engine = get_auto_exploit_engine()
    return await engine.auto_exploit_by_cve(target, cve_id, custom_vars)


async def exploit_cve_with_description(
    target: str,
    cve_id: str,
    description: str,
    severity: str = 'medium',
    custom_vars: Optional[Dict[str, str]] = None,
) -> AutoExploitResult:
    """
    便捷函数: 通过 CVE 描述利用

    Args:
        target: 目标 URL
        cve_id: CVE 编号
        description: CVE 描述
        severity: 严重性级别
        custom_vars: 自定义变量

    Returns:
        AutoExploitResult: 利用结果
    """
    engine = get_auto_exploit_engine()
    return await engine.exploit_with_description(
        target, cve_id, description, severity, custom_vars
    )


def generate_cve_poc(
    cve_id: str,
    description: str,
    severity: str = 'medium',
) -> Optional[str]:
    """
    便捷函数: 仅生成 PoC

    Args:
        cve_id: CVE 编号
        description: CVE 描述
        severity: 严重性级别

    Returns:
        YAML 格式的 PoC 模板
    """
    engine = get_auto_exploit_engine()
    return engine.generate_poc_only(cve_id, description, severity)


__all__ = [
    'CVEAutoExploitEngine',
    'AutoExploitResult',
    'AutoExploitStatus',
    'get_auto_exploit_engine',
    'auto_exploit_cve',
    'exploit_cve_with_description',
    'generate_cve_poc',
]
