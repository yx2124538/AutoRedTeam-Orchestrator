#!/usr/bin/env python3
"""
纯 Python 端口扫描器 - Pure Port Scanner
功能: TCP/UDP 扫描、服务识别、Banner抓取，无需 nmap 依赖

扫描方法可用性:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
| 方法          | 状态      | 说明                                           |
|---------------|-----------|------------------------------------------------|
| TCP Connect   | ✅ 可用   | 全连接扫描，无需特权，推荐使用                 |
| TCP SYN       | ❌ 未实现 | 需要 raw socket 和 root 权限，暂不支持         |
| UDP           | ✅ 可用   | UDP 端口扫描                                   |
| Service       | ✅ 可用   | 服务识别与 Banner 抓取                         |
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

使用示例:
    # 基础扫描
    from core.exploit.pure_scanner import PurePortScanner, quick_scan

    # 快速扫描常见端口
    result = quick_scan("192.168.1.1")

    # 异步扫描
    scanner = PurePortScanner()
    result = await scanner.scan_host("192.168.1.1", [22, 80, 443])

    # 带降级的扫描 (SYN 不可用时自动降级为 Connect)
    result = await scanner.scan_with_fallback("192.168.1.1", 80)
    if result.warnings:
        print(f"警告: {result.warnings}")

    # 检查扫描能力
    caps = PurePortScanner.get_scan_capabilities()
    print(f"SYN 扫描可用: {caps['tcp_syn']['available']}")  # False
"""

import asyncio
import socket
import struct
import time
import logging
import ipaddress
import ssl
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor
import re

# 导入统一并发控制管理器 (可选，用于性能监控)
try:
    from core.concurrency import get_collector
    _HAS_MONITORING = True
except ImportError:
    _HAS_MONITORING = False
    get_collector = None

logger = logging.getLogger(__name__)


class PortState(Enum):
    """端口状态"""
    OPEN = "open"
    CLOSED = "closed"
    FILTERED = "filtered"
    UNKNOWN = "unknown"


class ScanType(Enum):
    """扫描类型"""
    TCP_CONNECT = "tcp_connect"  # TCP 全连接
    TCP_SYN = "tcp_syn"  # TCP SYN (需要 root)
    UDP = "udp"
    SERVICE = "service"  # 服务识别


class SYNScanNotAvailable(NotImplementedError):
    """
    SYN 扫描不可用异常

    当 SYN 扫描因以下原因不可用时抛出:
    - 缺少 root/administrator 权限
    - 操作系统不支持 raw socket
    - 功能尚未完整实现
    """
    pass


@dataclass
class ServiceInfo:
    """服务信息"""
    name: str = "unknown"
    version: str = ""
    banner: str = ""
    product: str = ""
    extra_info: Dict[str, str] = field(default_factory=dict)


@dataclass
class PortResult:
    """端口扫描结果"""
    port: int
    state: PortState
    protocol: str = "tcp"
    service: Optional[ServiceInfo] = None
    response_time: float = 0.0
    warnings: List[str] = field(default_factory=list)  # 扫描警告信息


@dataclass
class HostResult:
    """主机扫描结果"""
    host: str
    ip: str
    is_up: bool = False
    ports: List[PortResult] = field(default_factory=list)
    os_guess: str = ""
    scan_time: float = 0.0
    warnings: List[str] = field(default_factory=list)  # 扫描警告信息
    scan_method: str = "tcp_connect"  # 实际使用的扫描方法


class ServiceProbe:
    """
    服务探测器 - 类似 nmap 的 nmap-service-probes
    """

    # 服务签名库
    SERVICE_SIGNATURES = {
        # HTTP 服务
        "http": {
            "probes": [b"GET / HTTP/1.0\r\n\r\n", b"HEAD / HTTP/1.1\r\nHost: localhost\r\n\r\n"],
            "patterns": [
                (r"HTTP/[\d.]+\s+\d+", "http"),
                (r"Server:\s*([^\r\n]+)", "server"),
                (r"X-Powered-By:\s*([^\r\n]+)", "powered_by"),
            ],
            "ports": [80, 8080, 8000, 8888, 3000, 5000, 8443],
        },
        # SSH 服务
        "ssh": {
            "probes": [b"\r\n"],
            "patterns": [
                (r"SSH-([\d.]+)-([^\r\n]+)", "ssh"),
                (r"OpenSSH[_\s]*([\d.p]+)", "openssh"),
                (r"Dropbear[_\s]*([\d.]+)", "dropbear"),
            ],
            "ports": [22, 2222],
        },
        # FTP 服务
        "ftp": {
            "probes": [b""],
            "patterns": [
                (r"220[- ](.+)", "ftp"),
                (r"vsFTPd\s+([\d.]+)", "vsftpd"),
                (r"ProFTPD\s+([\d.]+)", "proftpd"),
                (r"Pure-FTPd", "pureftpd"),
            ],
            "ports": [21],
        },
        # SMTP 服务
        "smtp": {
            "probes": [b""],
            "patterns": [
                (r"220[- ](.+)", "smtp"),
                (r"Postfix", "postfix"),
                (r"Microsoft ESMTP", "ms_smtp"),
                (r"Sendmail", "sendmail"),
            ],
            "ports": [25, 587, 465],
        },
        # MySQL
        "mysql": {
            "probes": [b""],
            "patterns": [
                (r"mysql_native_password", "mysql"),
                (r"([\d.]+)-MariaDB", "mariadb"),
                (r"([\d.]+)-MySQL", "mysql"),
            ],
            "ports": [3306],
        },
        # PostgreSQL
        "postgresql": {
            "probes": [b"\x00\x00\x00\x08\x04\xd2\x16\x2f"],  # SSLRequest
            "patterns": [
                (r"PostgreSQL", "postgresql"),
            ],
            "ports": [5432],
        },
        # Redis
        "redis": {
            "probes": [b"PING\r\n", b"INFO\r\n"],
            "patterns": [
                (r"\+PONG", "redis"),
                (r"redis_version:([\d.]+)", "redis"),
            ],
            "ports": [6379],
        },
        # MongoDB
        "mongodb": {
            "probes": [b""],
            "patterns": [
                (r"MongoDB", "mongodb"),
                (r"ismaster", "mongodb"),
            ],
            "ports": [27017],
        },
        # RDP
        "rdp": {
            "probes": [b"\x03\x00\x00\x13\x0e\xe0\x00\x00\x00\x00\x00\x01\x00\x08\x00\x03\x00\x00\x00"],
            "patterns": [
                (r"\x03\x00", "rdp"),
            ],
            "ports": [3389],
        },
        # SMB
        "smb": {
            "probes": [
                b"\x00\x00\x00\x85\xff\x53\x4d\x42\x72\x00\x00\x00\x00\x18\x53\xc8"
            ],
            "patterns": [
                (r"SMB", "smb"),
                (r"Windows", "windows_smb"),
            ],
            "ports": [445, 139],
        },
        # DNS
        "dns": {
            "probes": [b"\x00\x1e\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07version\x04bind\x00\x00\x10\x00\x03"],
            "patterns": [
                (r"bind", "bind"),
            ],
            "ports": [53],
        },
        # LDAP
        "ldap": {
            "probes": [b"\x30\x0c\x02\x01\x01\x60\x07\x02\x01\x03\x04\x00\x80\x00"],
            "patterns": [
                (r"LDAP", "ldap"),
            ],
            "ports": [389, 636],
        },
        # Telnet
        "telnet": {
            "probes": [b""],
            "patterns": [
                (r"login:", "telnet"),
                (r"Welcome", "telnet"),
            ],
            "ports": [23],
        },
    }

    # 常见端口服务映射
    DEFAULT_SERVICES = {
        21: "ftp", 22: "ssh", 23: "telnet", 25: "smtp", 53: "dns",
        80: "http", 110: "pop3", 111: "rpcbind", 135: "msrpc",
        139: "netbios-ssn", 143: "imap", 443: "https", 445: "microsoft-ds",
        993: "imaps", 995: "pop3s", 1433: "ms-sql-s", 1521: "oracle",
        3306: "mysql", 3389: "ms-wbt-server", 5432: "postgresql",
        5900: "vnc", 6379: "redis", 8080: "http-proxy", 8443: "https-alt",
        27017: "mongodb",
    }

    @classmethod
    async def probe_service(cls, host: str, port: int,
                            timeout: float = 5.0) -> ServiceInfo:
        """
        探测服务

        Args:
            host: 目标主机
            port: 端口号
            timeout: 超时时间
        """
        service = ServiceInfo()

        # 1. 首先尝试获取 Banner
        banner = await cls._grab_banner(host, port, timeout)
        if banner:
            service.banner = banner[:500]

        # 2. 尝试匹配已知服务签名
        for svc_name, svc_config in cls.SERVICE_SIGNATURES.items():
            if port in svc_config.get("ports", []) or banner:
                # 发送探测包
                for probe in svc_config["probes"]:
                    response = await cls._send_probe(host, port, probe, timeout)
                    if response:
                        service.banner = response[:500] if not service.banner else service.banner

                        # 匹配模式
                        for pattern, match_type in svc_config["patterns"]:
                            match = re.search(pattern, response, re.IGNORECASE)
                            if match:
                                service.name = svc_name
                                if match.groups():
                                    service.version = match.group(1)
                                return service

        # 3. 使用默认服务映射
        if not service.name or service.name == "unknown":
            service.name = cls.DEFAULT_SERVICES.get(port, "unknown")

        # 4. SSL/TLS 检测
        if await cls._is_ssl(host, port, timeout):
            service.extra_info["ssl"] = "true"
            if service.name == "http":
                service.name = "https"

        return service

    @classmethod
    async def _grab_banner(cls, host: str, port: int,
                           timeout: float) -> Optional[str]:
        """抓取 Banner"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )

            # 等待服务器发送 Banner
            try:
                banner = await asyncio.wait_for(
                    reader.read(1024),
                    timeout=2.0
                )
                writer.close()
                await writer.wait_closed()
                return banner.decode('utf-8', errors='ignore')
            except asyncio.TimeoutError:
                # 服务器没有主动发送，尝试发送探测
                writer.write(b"\r\n")
                await writer.drain()
                banner = await asyncio.wait_for(reader.read(1024), timeout=2.0)
                writer.close()
                await writer.wait_closed()
                return banner.decode('utf-8', errors='ignore')

        except Exception as e:
            logger.debug(f"Banner grab failed for {host}:{port} - {e}")
            return None

    @classmethod
    async def _send_probe(cls, host: str, port: int, probe: bytes,
                          timeout: float) -> Optional[str]:
        """发送探测包并获取响应"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )

            if probe:
                writer.write(probe)
                await writer.drain()

            response = await asyncio.wait_for(
                reader.read(2048),
                timeout=timeout
            )

            writer.close()
            await writer.wait_closed()

            return response.decode('utf-8', errors='ignore')

        except Exception as e:
            logger.debug(f"Probe failed for {host}:{port} - {e}")
            return None

    @classmethod
    async def _is_ssl(cls, host: str, port: int, timeout: float) -> bool:
        """检测是否为 SSL/TLS 服务"""
        try:
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port, ssl=ssl_context),
                timeout=timeout
            )
            writer.close()
            await writer.wait_closed()
            return True

        except (OSError, asyncio.TimeoutError):
            return False


class PurePortScanner:
    """
    纯 Python 端口扫描器

    Usage:
        scanner = PurePortScanner()

        # 扫描单个主机
        result = await scanner.scan_host("192.168.1.1", [22, 80, 443, 3306])

        # 扫描网段
        results = await scanner.scan_network("192.168.1.0/24", [22, 80])

        # 快速扫描常见端口
        result = await scanner.quick_scan("192.168.1.1")
    """

    # 常见端口列表
    COMMON_PORTS = [
        21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445,
        993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 6379, 8080, 8443,
        27017, 27018, 6443, 9200, 9300
    ]

    TOP_100_PORTS = [
        7, 9, 13, 21, 22, 23, 25, 26, 37, 53, 79, 80, 81, 88, 106, 110, 111,
        113, 119, 135, 139, 143, 144, 179, 199, 389, 427, 443, 444, 445,
        465, 513, 514, 515, 543, 544, 548, 554, 587, 631, 646, 873, 990,
        993, 995, 1025, 1026, 1027, 1028, 1029, 1110, 1433, 1720, 1723,
        1755, 1900, 2000, 2001, 2049, 2121, 2717, 3000, 3128, 3306, 3389,
        3986, 4899, 5000, 5009, 5051, 5060, 5101, 5190, 5357, 5432, 5631,
        5666, 5800, 5900, 6000, 6001, 6646, 7070, 8000, 8008, 8009, 8080,
        8081, 8443, 8888, 9100, 9999, 10000, 32768, 49152, 49153, 49154,
        49155, 49156, 49157
    ]

    def __init__(self,
                 concurrency: int = 100,
                 timeout: float = 3.0,
                 service_detection: bool = True,
                 retries: int = 1,
                 use_unified_manager: bool = True):
        """
        Args:
            concurrency: 并发连接数
            timeout: 连接超时
            service_detection: 是否进行服务识别
            retries: 重试次数
            use_unified_manager: 是否使用统一管理器 (性能监控+限流)
        """
        self.concurrency = concurrency
        self.timeout = timeout
        self.service_detection = service_detection
        self.retries = retries

        # 性能监控收集器 (可选)
        self.collector = get_collector() if _HAS_MONITORING and use_unified_manager else None

        self._semaphore: Optional[asyncio.Semaphore] = None

    async def _get_semaphore(self) -> asyncio.Semaphore:
        """获取信号量"""
        if self._semaphore is None:
            self._semaphore = asyncio.Semaphore(self.concurrency)
        return self._semaphore

    async def scan_port(self, host: str, port: int) -> PortResult:
        """
        扫描单个端口 - 集成性能监控

        Args:
            host: 目标主机
            port: 端口号
        """
        # 性能监控埋点 (已禁用，原 unified_concurrency 模块已删除)
        exec_id = None

        semaphore = await self._get_semaphore()

        async with semaphore:
            state = PortState.CLOSED
            response_time = 0.0
            service = None

            for attempt in range(self.retries + 1):
                start_time = time.time()

                try:
                    _, writer = await asyncio.wait_for(
                        asyncio.open_connection(host, port),
                        timeout=self.timeout
                    )
                    response_time = time.time() - start_time

                    # 端口开放
                    state = PortState.OPEN
                    writer.close()
                    await writer.wait_closed()

                    # 服务识别
                    if self.service_detection:
                        service = await ServiceProbe.probe_service(
                            host, port, self.timeout
                        )

                    # 记录成功 (监控已禁用)
                    break

                except asyncio.TimeoutError:
                    state = PortState.FILTERED
                except ConnectionRefusedError:
                    state = PortState.CLOSED
                    break
                except OSError as e:
                    if "Network is unreachable" in str(e):
                        state = PortState.FILTERED
                    else:
                        state = PortState.UNKNOWN
                except Exception as e:
                    logger.debug(f"Port scan error {host}:{port} - {e}")
                    state = PortState.UNKNOWN

            return PortResult(
                port=port,
                state=state,
                protocol="tcp",
                service=service,
                response_time=response_time
            )

    async def scan_host(self, host: str, ports: List[int]) -> HostResult:
        """
        扫描单个主机的多个端口 - 集成性能监控

        Args:
            host: 目标主机
            ports: 端口列表
        """
        # 性能监控埋点 (已禁用)
        exec_id = None

        start_time = time.time()

        # 解析主机名
        try:
            ip = socket.gethostbyname(host)
        except socket.gaierror:
            return HostResult(host=host, ip="", is_up=False)

        # 首先检查主机是否存活
        is_up = await self._check_host_alive(ip)

        if not is_up:
            return HostResult(host=host, ip=ip, is_up=False)

        # 扫描端口
        tasks = [self.scan_port(ip, port) for port in ports]
        results = await asyncio.gather(*tasks)

        # 过滤开放端口
        open_ports = [r for r in results if r.state == PortState.OPEN]

        return HostResult(
            host=host,
            ip=ip,
            is_up=True,
            ports=results,
            scan_time=time.time() - start_time
        )

    async def scan_network(self, cidr: str, ports: List[int]) -> List[HostResult]:
        """
        扫描网段

        Args:
            cidr: 网段 (如 192.168.1.0/24)
            ports: 端口列表
        """
        try:
            network = ipaddress.ip_network(cidr, strict=False)
        except ValueError as e:
            logger.error(f"Invalid CIDR: {cidr} - {e}")
            return []

        hosts = [str(ip) for ip in network.hosts()]
        results = []

        # 分批扫描
        batch_size = min(50, len(hosts))
        for i in range(0, len(hosts), batch_size):
            batch = hosts[i:i + batch_size]
            tasks = [self.scan_host(h, ports) for h in batch]
            batch_results = await asyncio.gather(*tasks)
            results.extend(batch_results)

            logger.info(f"Scanned {min(i + batch_size, len(hosts))}/{len(hosts)} hosts")

        return results

    async def quick_scan(self, host: str) -> HostResult:
        """快速扫描常见端口"""
        return await self.scan_host(host, self.COMMON_PORTS)

    async def full_scan(self, host: str, port_range: Tuple[int, int] = (1, 65535)) -> HostResult:
        """
        全端口扫描

        Args:
            host: 目标主机
            port_range: 端口范围 (start, end)
        """
        start, end = port_range
        ports = list(range(start, min(end + 1, 65536)))
        return await self.scan_host(host, ports)

    async def _check_host_alive(self, host: str) -> bool:
        """检查主机是否存活"""
        # 尝试连接常见端口
        for port in [80, 443, 22, 445]:
            try:
                _, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port),
                    timeout=1.0
                )
                writer.close()
                await writer.wait_closed()
                return True
            except (OSError, asyncio.TimeoutError):
                continue

        return True  # 即使连接失败也继续扫描

    async def syn_scan(self, host: str, port: int) -> PortResult:
        """
        SYN 扫描 (半开放扫描)

        ⚠️ 当前状态: 未实现
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        SYN 扫描需要以下条件，当前版本尚未完整实现:
        1. root/administrator 权限 (创建 raw socket)
        2. 完整的 TCP/IP 包构造逻辑
        3. 操作系统支持 (Windows 限制较多)

        替代方案:
        - 使用 scan_port() 进行 TCP Connect 扫描 (无需特权，推荐)
        - 使用 scan_with_fallback() 自动降级

        Raises:
            SYNScanNotAvailable: 始终抛出，表明功能不可用

        Args:
            host: 目标主机
            port: 端口号

        Returns:
            永远不会返回，总是抛出异常
        """
        raise SYNScanNotAvailable(
            "SYN 扫描功能尚未实现。\n"
            "原因: 需要 raw socket 权限和完整的 TCP/IP 包构造逻辑。\n"
            "替代方案: 请使用 scan_port() 进行 TCP Connect 扫描，"
            "或使用 scan_with_fallback() 自动降级。"
        )

    async def scan_with_fallback(
        self,
        host: str,
        port: int,
        preferred_method: ScanType = ScanType.TCP_SYN
    ) -> PortResult:
        """
        带自动降级的端口扫描

        当首选扫描方法不可用时，自动降级到 TCP Connect 扫描。

        Args:
            host: 目标主机
            port: 端口号
            preferred_method: 首选扫描方法 (默认 SYN)

        Returns:
            PortResult: 包含扫描结果和降级警告
        """
        warnings = []

        if preferred_method == ScanType.TCP_SYN:
            # SYN 扫描不可用，降级到 Connect 扫描
            warnings.append(
                "SYN 扫描不可用 (功能未实现)，已自动降级为 TCP Connect 扫描"
            )
            logger.warning(
                f"SYN scan unavailable for {host}:{port}, "
                "falling back to TCP Connect scan"
            )

        # 执行 TCP Connect 扫描
        result = await self.scan_port(host, port)
        result.warnings.extend(warnings)

        return result

    @staticmethod
    def is_syn_scan_available() -> bool:
        """
        检查 SYN 扫描是否可用

        Returns:
            bool: 当前版本始终返回 False
        """
        return False

    @staticmethod
    def get_scan_capabilities() -> Dict[str, Any]:
        """
        获取扫描器能力信息

        Returns:
            Dict: 包含各扫描方法的可用性状态
        """
        return {
            "tcp_connect": {
                "available": True,
                "requires_root": False,
                "description": "TCP 全连接扫描，可靠但会留下日志"
            },
            "tcp_syn": {
                "available": False,
                "requires_root": True,
                "description": "SYN 半开放扫描 (未实现)",
                "not_implemented_reason": "需要 raw socket 和完整 TCP/IP 包构造"
            },
            "udp": {
                "available": True,
                "requires_root": False,
                "description": "UDP 端口扫描"
            },
            "service": {
                "available": True,
                "requires_root": False,
                "description": "服务识别与 Banner 抓取"
            }
        }


class UDPScanner:
    """UDP 端口扫描器"""

    UDP_PROBES = {
        53: b"\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00",  # DNS
        161: b"\x30\x26\x02\x01\x01\x04\x06public",  # SNMP
        123: b"\xe3\x00\x04\xfa",  # NTP
        137: b"\x80\x94\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00",  # NetBIOS
    }

    def __init__(self, timeout: float = 3.0):
        self.timeout = timeout

    async def scan_port(self, host: str, port: int) -> PortResult:
        """扫描 UDP 端口"""
        try:
            # 创建 UDP socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(self.timeout)

            # 获取探测包
            probe = self.UDP_PROBES.get(port, b"\x00")

            sock.sendto(probe, (host, port))

            try:
                data, _ = sock.recvfrom(1024)
                sock.close()
                return PortResult(
                    port=port,
                    state=PortState.OPEN,
                    protocol="udp",
                    service=ServiceInfo(banner=data.decode('utf-8', errors='ignore')[:100])
                )
            except socket.timeout:
                sock.close()
                return PortResult(port=port, state=PortState.FILTERED, protocol="udp")

        except Exception as e:
            logger.debug(f"UDP scan error {host}:{port} - {e}")
            return PortResult(port=port, state=PortState.UNKNOWN, protocol="udp")


# 同步包装器
def run_async(coro):
    """运行异步协程 (Python 3.10+ 兼容)"""
    try:
        asyncio.get_running_loop()
        import concurrent.futures
        with concurrent.futures.ThreadPoolExecutor() as pool:
            return pool.submit(asyncio.run, coro).result()
    except RuntimeError:
        return asyncio.run(coro)


# 便捷函数
def scan_ports(host: str, ports: List[int], concurrency: int = 100) -> Dict[str, Any]:
    """
    扫描端口 (同步接口)

    Usage:
        result = scan_ports("192.168.1.1", [22, 80, 443])
        for port in result["open_ports"]:
            print(f"Port {port['port']} is open - {port['service']}")
    """
    scanner = PurePortScanner(concurrency=concurrency)
    result = run_async(scanner.scan_host(host, ports))

    return {
        "host": result.host,
        "ip": result.ip,
        "is_up": result.is_up,
        "open_ports": [
            {
                "port": p.port,
                "state": p.state.value,
                "service": p.service.name if p.service else "unknown",
                "version": p.service.version if p.service else "",
                "banner": p.service.banner[:100] if p.service and p.service.banner else "",
                "warnings": p.warnings,
            }
            for p in result.ports if p.state == PortState.OPEN
        ],
        "total_scanned": len(result.ports),
        "scan_time": result.scan_time,
        "scan_method": result.scan_method,
        "warnings": result.warnings,
        "capabilities": PurePortScanner.get_scan_capabilities(),
    }


def scan_network(cidr: str, ports: List[int] = None) -> List[Dict[str, Any]]:
    """
    扫描网段 (同步接口)

    Usage:
        results = scan_network("192.168.1.0/24", [22, 80])
        for host in results:
            if host["is_up"]:
                print(f"{host['ip']} - {len(host['open_ports'])} open ports")
    """
    scanner = PurePortScanner()
    ports = ports or PurePortScanner.COMMON_PORTS

    results = run_async(scanner.scan_network(cidr, ports))

    return [
        {
            "host": r.host,
            "ip": r.ip,
            "is_up": r.is_up,
            "open_ports": [
                {
                    "port": p.port,
                    "service": p.service.name if p.service else "unknown",
                    "warnings": p.warnings,
                }
                for p in r.ports if p.state == PortState.OPEN
            ],
            "scan_method": r.scan_method,
            "warnings": r.warnings,
        }
        for r in results
    ]


def quick_scan(host: str) -> Dict[str, Any]:
    """快速扫描 (同步接口)"""
    scanner = PurePortScanner()
    result = run_async(scanner.quick_scan(host))

    open_ports = [p for p in result.ports if p.state == PortState.OPEN]

    return {
        "host": result.host,
        "ip": result.ip,
        "is_up": result.is_up,
        "open_ports": [
            {
                "port": p.port,
                "service": p.service.name if p.service else "unknown",
                "banner": p.service.banner[:50] if p.service and p.service.banner else "",
                "warnings": p.warnings,
            }
            for p in open_ports
        ],
        "scan_time": f"{result.scan_time:.2f}s",
        "scan_method": result.scan_method,
        "warnings": result.warnings,
        "syn_scan_available": PurePortScanner.is_syn_scan_available(),
    }


if __name__ == "__main__":
    import sys
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

    target = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"

    logger.info(f"Scanning {target}...")
    logger.info("=" * 50)

    result = quick_scan(target)

    logger.info(f"Host: {result['host']} ({result['ip']})")
    logger.info(f"Status: {'Up' if result['is_up'] else 'Down'}")
    logger.info(f"Scan Time: {result['scan_time']}")
    logger.info(f"\nOpen Ports ({len(result['open_ports'])}):")

    for port_info in result['open_ports']:
        logger.info(f"  {port_info['port']}/tcp - {port_info['service']}")
        if port_info.get('banner'):
            logger.info(f"    Banner: {port_info['banner']}")
